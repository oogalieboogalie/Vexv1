// src/vexc/eval.vex
// Tiny evaluator for the list-AST emitted by `src/vexc/stmt.vex`.

use "./program.vex"

// Return/control pair.
// kind: 0=none, 1=return, 2=break, 3=continue
fn vexc_res(kind, value) {
    let r = list_create()
    list_push(r, kind)
    list_push(r, value)
    return r
}

fn vexc_res_has(r) { return list_get(r, 0) }
fn vexc_res_val(r) { return list_get(r, 1) }

fn vexc_is_ident_char(c) {
    let ok = 0
    if c == 95 { let ok = 1 }
    if ok == 0 and 47 < c and c < 58 { let ok = 1 }
    if ok == 0 and 64 < c and c < 91 { let ok = 1 }
    if ok == 0 and 96 < c and c < 123 { let ok = 1 }
    return ok
}

fn vexc_render_string(vals_env, defs_env, raw) {
    let i = 0
    let n = str_len(raw)
    while i < n {
        let c = str_char(raw, i)

        if c == 123 {
            let j = i + 1
            while j < n and str_char(raw, j) != 125 { let j = j + 1 }

            if j < n {
                let expr = str_slice(raw, i + 1, j)
                let k = 0
                let elen = str_len(expr)

                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }
                let start_name = k
                while k < elen and vexc_is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                let name = str_slice(expr, start_name, k)

                let def = env_find(defs_env, name)
                if def != 0 {
                    let v = env_find(vals_env, name)
                    print(v)
                }
                if def == 0 {
                    print_char(123)
                    print_bytes(name)
                    print_char(125)
                }

                let i = j + 1
            }

            if j >= n {
                print_char(123)
                let i = i + 1
            }
        }

        if c != 123 {
            let handled = 0
            if c == 92 and (i + 1) < n and str_char(raw, i + 1) == 110 {
                print_char(10)
                let i = i + 2
                let handled = 1
            }
            if handled == 0 {
                print_char(c)
                let i = i + 1
            }
        }
    }
    return 0
}

fn vexc_env_get(vals_env, defs_env, name) {
    let def = env_find(defs_env, name)
    if def == 0 {
        print("[vexc] error: undefined var {name}\n")
        return 0
    }
    return env_find(vals_env, name)
}

fn vexc_eval_expr(expr, funcs_env, vals_env, defs_env) {
    let tag = list_get(expr, 0)

    if tag == 300 { return list_get(expr, 1) }
    if tag == 301 { return list_get(expr, 1) }

    if tag == 302 {
        let name = list_get(expr, 1)
        return vexc_env_get(vals_env, defs_env, name)
    }

    if tag == 303 {
        let op = list_get(expr, 1)
        let left = vexc_eval_expr(list_get(expr, 2), funcs_env, vals_env, defs_env)
        let right = vexc_eval_expr(list_get(expr, 3), funcs_env, vals_env, defs_env)
        if op == 18 { return left + right }
        if op == 19 { return left - right }
        if op == 20 { return left * right }
        if op == 21 { return left / right }
        if op == 22 {
            if left < right { return 1 }
            return 0
        }
        if op == 23 {
            if left <= right { return 1 }
            return 0
        }
        if op == 16 {
            if left == right { return 1 }
            return 0
        }
        if op == 17 {
            if left != right { return 1 }
            return 0
        }
        return 0
    }

    if tag == 304 {
        let name = list_get(expr, 1)
        let arg_exprs = list_get(expr, 2)

        let argc = list_len(arg_exprs)
        let args = list_create()
        let i = 0
        while i < argc {
            list_push(args, vexc_eval_expr(list_get(arg_exprs, i), funcs_env, vals_env, defs_env))
            let i = i + 1
        }

        // Builtins
        if name == "env_create" {
            let parent = 0
            if argc > 0 { let parent = list_get(args, 0) }
            return env_create(parent)
        }
        if name == "env_set" {
            let envh = 0
            let key = ""
            let val = 0
            if argc > 0 { let envh = list_get(args, 0) }
            if argc > 1 { let key = list_get(args, 1) }
            if argc > 2 { let val = list_get(args, 2) }
            env_set(envh, key, val)
            return 0
        }
        if name == "env_find" {
            let envh = 0
            let key = ""
            if argc > 0 { let envh = list_get(args, 0) }
            if argc > 1 { let key = list_get(args, 1) }
            return env_find(envh, key)
        }

        if name == "str_len" {
            if argc > 0 { return str_len(list_get(args, 0)) }
            return 0
        }
        if name == "str_char" {
            if argc > 1 { return str_char(list_get(args, 0), list_get(args, 1)) }
            return 0
        }
        if name == "str_slice" {
            if argc > 2 { return str_slice(list_get(args, 0), list_get(args, 1), list_get(args, 2)) }
            return ""
        }

        if name == "print_bytes" {
            if argc > 0 { print_bytes(list_get(args, 0)) }
            return 0
        }
        if name == "print_char" {
            if argc > 0 { print_char(list_get(args, 0)) }
            return 0
        }

        if name == "list_create" { return list_create() }
        if name == "list_push" {
            if argc > 1 { list_push(list_get(args, 0), list_get(args, 1)) }
            return 0
        }
        if name == "list_len" {
            if argc > 0 { return list_len(list_get(args, 0)) }
            return 0
        }
        if name == "list_get" {
            if argc > 1 { return list_get(list_get(args, 0), list_get(args, 1)) }
            return 0
        }
        if name == "list_set" {
            if argc > 2 { list_set(list_get(args, 0), list_get(args, 1), list_get(args, 2)) }
            return 0
        }

        if name == "read_file" {
            if argc > 0 { return read_file(list_get(args, 0)) }
            return ""
        }
        if name == "write_file" {
            if argc > 1 { write_file(list_get(args, 0), list_get(args, 1)) }
            return 0
        }

        if name == "path_join" {
            if argc > 1 { return path_join(list_get(args, 0), list_get(args, 1)) }
            return ""
        }

        let f = env_find(funcs_env, name)
        if f == 0 {
            print("[vexc] error: undefined function {name}\n")
            return 0
        }

        return vexc_call_user_func(f, args, funcs_env, vals_env, defs_env)
    }

    return 0
}

fn vexc_eval_stmt(stmt, funcs_env, vals_env, defs_env) {
    let tag = list_get(stmt, 0)

    if tag == 102 {
        return vexc_eval_block(stmt, funcs_env, vals_env, defs_env)
    }

    if tag == 201 {
        let expr = list_get(stmt, 1)
        if list_get(expr, 0) == 301 {
            vexc_render_string(vals_env, defs_env, list_get(expr, 1))
        }
        if list_get(expr, 0) != 301 {
            let v = vexc_eval_expr(expr, funcs_env, vals_env, defs_env)
            print(v)
        }
        return vexc_res(0, 0)
    }

    if tag == 200 {
        let name = list_get(stmt, 1)
        let expr = list_get(stmt, 2)
        let v = vexc_eval_expr(expr, funcs_env, vals_env, defs_env)
        env_set(vals_env, name, v)
        env_set(defs_env, name, 1)
        return vexc_res(0, 0)
    }

    if tag == 206 {
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        let expr = list_get(stmt, 3)
        let v = vexc_eval_expr(expr, funcs_env, vals_env, defs_env)

        if op == 30 {
            let base = vexc_env_get(vals_env, defs_env, name)
            let v = base + v
        }

        env_set(vals_env, name, v)
        env_set(defs_env, name, 1)
        return vexc_res(0, 0)
    }

    if tag == 202 {
        let expr = list_get(stmt, 1)
        let v = 0
        if expr != 0 { let v = vexc_eval_expr(expr, funcs_env, vals_env, defs_env) }
        return vexc_res(1, v)
    }

    if tag == 209 { return vexc_res(2, 0) }
    if tag == 210 { return vexc_res(3, 0) }

    if tag == 204 {
        let cond = list_get(stmt, 1)
        let body = list_get(stmt, 2)

        while vexc_eval_expr(cond, funcs_env, vals_env, defs_env) != 0 {
            let r = vexc_eval_block(body, funcs_env, vals_env, defs_env)
            let k = vexc_res_has(r)
            if k == 1 { return r }
            if k == 2 { return vexc_res(0, 0) }
        }
        return vexc_res(0, 0)
    }

    if tag == 207 {
        let name = list_get(stmt, 1)
        let start = vexc_eval_expr(list_get(stmt, 2), funcs_env, vals_env, defs_env)
        let end = vexc_eval_expr(list_get(stmt, 3), funcs_env, vals_env, defs_env)
        let body = list_get(stmt, 4)
        while start < end {
            if str_len(name) != 0 {
                env_set(vals_env, name, start)
                env_set(defs_env, name, 1)
            }
            let r = vexc_eval_block(body, funcs_env, vals_env, defs_env)
            let k = vexc_res_has(r)
            if k == 1 { return r }
            if k == 2 { return vexc_res(0, 0) }
            let start = start + 1
        }
        return vexc_res(0, 0)
    }

    if tag == 203 {
        let cond = list_get(stmt, 1)
        let then_block = list_get(stmt, 2)
        let else_block = list_get(stmt, 3)
        let c = vexc_eval_expr(cond, funcs_env, vals_env, defs_env)
        if c != 0 { return vexc_eval_block(then_block, funcs_env, vals_env, defs_env) }
        if else_block != 0 { return vexc_eval_block(else_block, funcs_env, vals_env, defs_env) }
        return vexc_res(0, 0)
    }

    if tag == 205 {
        let expr = list_get(stmt, 1)
        _ = vexc_eval_expr(expr, funcs_env, vals_env, defs_env)
        return vexc_res(0, 0)
    }

    print("[vexc] error: unsupported stmt tag\n")
    return vexc_res(0, 0)
}

fn vexc_eval_block(block, funcs_env, vals_env, defs_env) {
    let stmts = list_get(block, 1)
    let i = 0
    while i < list_len(stmts) {
        let r = vexc_eval_stmt(list_get(stmts, i), funcs_env, vals_env, defs_env)
        if vexc_res_has(r) != 0 { return r }
        let i = i + 1
    }
    return vexc_res(0, 0)
}

fn vexc_call_user_func(func_node, args, funcs_env, caller_vals, caller_defs) {
    let parent_vals = caller_vals
    let parent_defs = caller_defs

    let vals_env = env_create(parent_vals)
    let defs_env = env_create(parent_defs)

    let params = list_get(func_node, 7)
    let argc = list_len(args)
    let pi = 0
    while pi < list_len(params) and pi < argc {
        let name = list_get(params, pi)
        env_set(vals_env, name, list_get(args, pi))
        env_set(defs_env, name, 1)
        let pi = pi + 1
    }

    let body = list_get(func_node, 6)
    let r = vexc_eval_block(body, funcs_env, vals_env, defs_env)
    let k = vexc_res_has(r)
    if k == 1 { return vexc_res_val(r) }
    if k != 0 {
        print("[vexc] error: break/continue escaped function\n")
        return 0
    }
    return 0
}

fn vexc_eval_program(prog) {
    let tag = list_get(prog, 0)
    if tag != 100 {
        print("[vexc] error: expected program\n")
        return 0
    }

    let funcs = list_get(prog, 1)
    let funcs_env = env_create()

    let i = 0
    while i < list_len(funcs) {
        let f = list_get(funcs, i)
        let name = list_get(f, 1)
        env_set(funcs_env, name, f)
        let i = i + 1
    }

    let mainf = env_find(funcs_env, "main")
    if mainf == 0 {
        print("[vexc] error: missing main\n")
        return 0
    }

    let vals = env_create()
    let defs = env_create()
    let args = list_create()
    return vexc_call_user_func(mainf, args, funcs_env, vals, defs)
}
