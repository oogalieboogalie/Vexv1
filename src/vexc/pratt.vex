// src/vexc/pratt.vex
// Core-Vex Pratt expression parser + tiny evaluator over the AST.
//
// AST tags match `src/compiler_core.vex`:
// - int  [300, value]
// - str  [301, value]
// - name [302, ident]
// - bin  [303, op_kind, left, right]
// - call [304, callee, args]

fn vexc_pair(a, b) {
    let p = list_create()
    list_push(p, a)
    list_push(p, b)
    return p
}

fn vexc_pair_node(p) { return list_get(p, 0) }
fn vexc_pair_pos(p) { return list_get(p, 1) }

fn vexc_tok_kind(toks, pos) {
    let idx = pos * 4
    if idx < list_len(toks) { return list_get(toks, idx) }
    return 0
}

fn vexc_tok_text(toks, pos) {
    let idx = pos * 4 + 1
    if idx < list_len(toks) { return list_get(toks, idx) }
    return ""
}

fn vexc_tok_line(toks, pos) {
    let idx = pos * 4 + 2
    if idx < list_len(toks) { return list_get(toks, idx) }
    return 0
}

fn vexc_tok_col(toks, pos) {
    let idx = pos * 4 + 3
    if idx < list_len(toks) { return list_get(toks, idx) }
    return 0
}

fn vexc_line_slice(src, target_line) {
    let n = str_len(src)
    let i = 0
    let line = 1
    let start = 0
    while i < n {
        let c = str_char(src, i)
        if c == 10 {
            if line == target_line { return str_slice(src, start, i) }
            let line = line + 1
            let i = i + 1
            let start = i
            continue
        }
        let i = i + 1
    }
    if line == target_line { return str_slice(src, start, n) }
    return ""
}

fn vexc_print_caret(col) {
    let i = 1
    while i < col {
        print(" ")
        let i = i + 1
    }
    print("^\n")
    return 0
}

fn vexc_error_at(toks, pos, path, src, msg) {
    let line = vexc_tok_line(toks, pos)
    let col = vexc_tok_col(toks, pos)
    if str_len(path) != 0 {
        print("[vexc] error: {path}:{line}:{col}: {msg}\n")
        let src_text = src
        if str_len(src_text) == 0 {
            let src_text = read_file(path)
        }
        if str_len(src_text) != 0 {
            let line_text = vexc_line_slice(src_text, line)
            if str_len(line_text) != 0 {
                print(line_text)
                print("\n")
                let caret_col = col
                if caret_col < 1 { let caret_col = 1 }
                vexc_print_caret(caret_col)
            }
        }
        return 0
    }
    print("[vexc] error: {line}:{col}: {msg}\n")
    if str_len(src) != 0 {
        let line_text = vexc_line_slice(src, line)
        if str_len(line_text) != 0 {
            print(line_text)
            print("\n")
            let caret_col = col
            if caret_col < 1 { let caret_col = 1 }
            vexc_print_caret(caret_col)
        }
    }
    return 0
}

fn vexc_parse_int(s) {
    let v = 0
    let i = 0
    let n = str_len(s)
    while i < n {
        let c = str_char(s, i)
        if c < 48 { return v }
        if 57 < c { return v }
        let v = v * 10 + (c - 48)
        let i = i + 1
    }
    return v
}

fn vexc_strip_quotes(s) {
    let n = str_len(s)
    if n < 2 { return s }
    if str_char(s, 0) == 34 and str_char(s, n - 1) == 34 {
        return str_slice(s, 1, n - 1)
    }
    return s
}

fn vexc_infix_lbp(op) {
    if op == 20 or op == 21 { return 100 }
    if op == 18 or op == 19 { return 90 }
    if op == 22 or op == 23 or op == 26 or op == 27 { return 80 }
    if op == 16 or op == 17 { return 70 }
    if op == 24 { return 60 }
    if op == 25 { return 50 }
    return 0
}

fn vexc_infix_rbp(op) {
    if op == 20 or op == 21 { return 101 }
    if op == 18 or op == 19 { return 91 }
    if op == 22 or op == 23 or op == 26 or op == 27 { return 81 }
    if op == 16 or op == 17 { return 71 }
    if op == 24 { return 61 }
    if op == 25 { return 51 }
    return 0
}

fn vexc_prefix_expr(toks, pos, path, src) {
    let k = vexc_tok_kind(toks, pos)

    if k == 31 {
        let node = list_create()
        list_push(node, 300)
        list_push(node, 1)
        return vexc_pair(node, pos + 1)
    }
    if k == 32 {
        let node = list_create()
        list_push(node, 300)
        list_push(node, 0)
        return vexc_pair(node, pos + 1)
    }
    if k == 33 {
        let node = list_create()
        list_push(node, 300)
        list_push(node, 0)
        return vexc_pair(node, pos + 1)
    }

    if k == 2 {
        let txt = vexc_tok_text(toks, pos)
        let node = list_create()
        list_push(node, 300)
        list_push(node, vexc_parse_int(txt))
        return vexc_pair(node, pos + 1)
    }

    if k == 3 {
        let raw = vexc_tok_text(toks, pos)
        let node = list_create()
        list_push(node, 301)
        list_push(node, vexc_strip_quotes(raw))
        return vexc_pair(node, pos + 1)
    }

    // dot-literal: .name -> "name"
    if k == 29 {
        if vexc_tok_kind(toks, pos + 1) == 1 {
            let name = vexc_tok_text(toks, pos + 1)
            let node = list_create()
            list_push(node, 301)
            list_push(node, name)
            return vexc_pair(node, pos + 2)
        }
        let node = list_create()
        list_push(node, 301)
        list_push(node, "")
        return vexc_pair(node, pos + 1)
    }

    if k == 1 {
        let name = vexc_tok_text(toks, pos)
        let node = list_create()
        list_push(node, 302)
        list_push(node, name)
        return vexc_pair(node, pos + 1)
    }

    if k == 11 {
        let r = vexc_parse_expr_bp(toks, pos + 1, 0, path, src)
        let expr = vexc_pair_node(r)
        let pos = vexc_pair_pos(r)
        let close_k = vexc_tok_kind(toks, pos)
        if close_k != 12 { vexc_error_at(toks, pos, path, src, "expected ')'") }
        if close_k == 12 { let pos = pos + 1 }
        return vexc_pair(expr, pos)
    }

    let node = list_create()
    list_push(node, 302)
    list_push(node, "")
    return vexc_pair(node, pos + 1)
}

fn vexc_parse_expr_bp(toks, pos, min_bp, path, src) {
    let r = vexc_prefix_expr(toks, pos, path, src)
    let lhs = vexc_pair_node(r)
    let pos = vexc_pair_pos(r)

    // postfix: calls, indexing, and dot
    while 1 {
        // call postfix: name(args...)
        if vexc_tok_kind(toks, pos) == 11 {
            if list_get(lhs, 0) != 302 { break }
            let name = list_get(lhs, 1)

            let pos = pos + 1 // '('
            let args = list_create()
            while vexc_tok_kind(toks, pos) != 12 and vexc_tok_kind(toks, pos) != 0 {
                let r2 = vexc_parse_expr_bp(toks, pos, 0, path, src)
                list_push(args, vexc_pair_node(r2))
                let pos = vexc_pair_pos(r2)
            }
            let close_k = vexc_tok_kind(toks, pos)
            if close_k != 12 { vexc_error_at(toks, pos, path, src, "expected ')' after call args") }
            if close_k == 12 { let pos = pos + 1 }

            let node = list_create()
            list_push(node, 304)
            list_push(node, name)
            list_push(node, args)
            let lhs = node
            continue
        }

        // indexing postfix: xs[i] -> list_get(xs, i)
        if vexc_tok_kind(toks, pos) == 37 {
            let r2 = vexc_parse_expr_bp(toks, pos + 1, 0, path, src)
            let idx_expr = vexc_pair_node(r2)
            let pos = vexc_pair_pos(r2)
            let close_k = vexc_tok_kind(toks, pos)
            if close_k != 38 { vexc_error_at(toks, pos, path, src, "expected ']'") }
            if close_k == 38 { let pos = pos + 1 }

            let args = list_create()
            list_push(args, lhs)
            list_push(args, idx_expr)

            let node = list_create()
            list_push(node, 304)
            list_push(node, "list_get")
            list_push(node, args)
            let lhs = node
            continue
        }

        // dot postfix: obj.field -> env_find(obj, "field")
        if vexc_tok_kind(toks, pos) == 29 {
            if vexc_tok_kind(toks, pos + 1) != 1 { break }
            let field = vexc_tok_text(toks, pos + 1)

            let field_node = list_create()
            list_push(field_node, 301)
            list_push(field_node, field)

            let args = list_create()
            list_push(args, lhs)
            list_push(args, field_node)

            let node = list_create()
            list_push(node, 304)
            list_push(node, "env_find")
            list_push(node, args)
            let lhs = node
            let pos = pos + 2
            continue
        }

        break
    }

    while 1 {
        let op = vexc_tok_kind(toks, pos)
        let l_bp = vexc_infix_lbp(op)
        if l_bp == 0 { break }
        if l_bp < min_bp { break }

        let r_bp = vexc_infix_rbp(op)
        let r2 = vexc_parse_expr_bp(toks, pos + 1, r_bp, path, src)
        let rhs = vexc_pair_node(r2)
        let pos = vexc_pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, op)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }

    return vexc_pair(lhs, pos)
}

fn vexc_parse_expr(toks, pos, path, src) { return vexc_parse_expr_bp(toks, pos, 0, path, src) }

fn vexc_op_name(op) {
    if op == 18 { return "+" }
    if op == 19 { return "-" }
    if op == 20 { return "*" }
    if op == 21 { return "/" }
    if op == 22 { return "<" }
    if op == 23 { return "<=" }
    if op == 26 { return ">" }
    if op == 27 { return ">=" }
    if op == 16 { return "==" }
    if op == 17 { return "!=" }
    if op == 24 { return "and" }
    if op == 25 { return "or" }
    return "?"
}

fn vexc_dump_expr(expr, depth, max_depth) {
    if depth > max_depth { return }

    let tag = list_get(expr, 0)

    if tag == 300 {
        let v = list_get(expr, 1)
        print("Int ")
        print(v)
        print("\n")
        return
    }

    if tag == 301 {
        let s = list_get(expr, 1)
        print("Str ")
        print(s)
        print("\n")
        return
    }

    if tag == 302 {
        let name = list_get(expr, 1)
        print("Name ")
        print(name)
        print("\n")
        return
    }

    if tag == 304 {
        let callee = list_get(expr, 1)
        let args = list_get(expr, 2)
        print("Call ")
        print(callee)
        print(" argc=")
        print(list_len(args))
        print("\n")
        let i = 0
        while i < list_len(args) {
            vexc_dump_expr(list_get(args, i), depth + 1, max_depth)
            let i = i + 1
        }
        return
    }

    if tag == 303 {
        let op = list_get(expr, 1)
        print("Bin ")
        print(vexc_op_name(op))
        print("\n")
        vexc_dump_expr(list_get(expr, 2), depth + 1, max_depth)
        vexc_dump_expr(list_get(expr, 3), depth + 1, max_depth)
        return
    }

    print("UnknownExpr tag={tag}\n")
}

fn vexc_eval_expr(expr) {
    let tag = list_get(expr, 0)

    if tag == 300 { return list_get(expr, 1) }

    if tag == 303 {
        let op = list_get(expr, 1)
        let left = vexc_eval_expr(list_get(expr, 2))
        let right = vexc_eval_expr(list_get(expr, 3))
        if op == 18 { return left + right }
        if op == 19 { return left - right }
        if op == 20 { return left * right }
        if op == 21 { return left / right }
        if op == 22 {
            if left < right { return 1 }
            return 0
        }
        if op == 23 {
            if left <= right { return 1 }
            return 0
        }
        return 0
    }

    // name/call: not evaluated yet in this tiny demo
    return 0
}
