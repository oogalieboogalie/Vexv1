// src/vexc/program.vex
// Parse a program of top-level `fn` definitions into the same list-AST tags as `compiler_core.vex`.
//
// Program: [100, funcs]
// Func:    [101, name, p1, p2, p3, is_accel, body_block, params]

use "./stmt.vex"
use "./tokenize.vex"

fn vexc_list_extend(dst, src) {
    let i = 0
    let n = list_len(src)
    while i < n {
        list_push(dst, list_get(src, i))
        let i = i + 1
    }
    return 0
}

fn vexc_path_dirname(path) {
    let n = str_len(path)
    let i = n - 1
    while i >= 0 {
        let c = str_char(path, i)
        if c == 47 or c == 92 { return str_slice(path, 0, i) }
        let i = i - 1
    }
    return ""
}

fn vexc_str_eq(a, b) {
    let n = str_len(a)
    if n != str_len(b) { return 0 }
    let i = 0
    while i < n {
        if str_char(a, i) != str_char(b, i) { return 0 }
        let i = i + 1
    }
    return 1
}

fn vexc_token_cache_create() {
    return env_create(0)
}

fn vexc_tokenize_cached(path, token_cache) {
    let src = read_file(path)
    let cached = env_find(token_cache, path)
    if cached != 0 {
        let cached_src = list_get(cached, 0)
        if vexc_str_eq(cached_src, src) != 0 {
            return list_get(cached, 1)
        }
    }

    let toks = vexc_tokenize(src)
    let entry = list_create()
    list_push(entry, src)
    list_push(entry, toks)
    env_set(token_cache, path, entry)
    return toks
}

fn vexc_parse_func(toks, pos, is_accel, path) {
    // consume 'fn'
    if vexc_tok_kind(toks, pos) == 6 { let pos = pos + 1 }

    let name = ""
    let name_k = vexc_tok_kind(toks, pos)
    if name_k != 1 { vexc_error_at(toks, pos, "", "fn expects a name") }
    if name_k == 1 {
        let name = vexc_tok_text(toks, pos)
        let pos = pos + 1
    }

    let p1 = ""
    let p2 = ""
    let p3 = ""
    let params = list_create()
    let param_i = 0

    if vexc_tok_kind(toks, pos) == 11 {
        let pos = pos + 1
        while vexc_tok_kind(toks, pos) != 12 and vexc_tok_kind(toks, pos) != 0 {
            if vexc_tok_kind(toks, pos) == 1 {
                if param_i == 0 { let p1 = vexc_tok_text(toks, pos) }
                if param_i == 1 { let p2 = vexc_tok_text(toks, pos) }
                if param_i == 2 { let p3 = vexc_tok_text(toks, pos) }
                list_push(params, vexc_tok_text(toks, pos))
                let param_i = param_i + 1
            }
            let pos = pos + 1
        }
        let close_k = vexc_tok_kind(toks, pos)
        if close_k != 12 { vexc_error_at(toks, pos, "", "expected ')' after params") }
        if close_k == 12 { let pos = pos + 1 }
    }

    while vexc_tok_kind(toks, pos) != 13 and vexc_tok_kind(toks, pos) != 0 { let pos = pos + 1 }
    if vexc_tok_kind(toks, pos) != 13 {
        vexc_error_at(toks, pos, "", "expected '{' to start function body")
    }
    let br = vexc_parse_block(toks, pos, path)
    let body = vexc_pair_node(br)
    let pos = vexc_pair_pos(br)

    let node = list_create()
    list_push(node, 101)
    list_push(node, name)
    list_push(node, p1)
    list_push(node, p2)
    list_push(node, p3)
    list_push(node, is_accel)
    list_push(node, body)
    list_push(node, params)
    return vexc_pair(node, pos)
}

fn vexc_parse_program_with_imports(toks, path, imports_seen, token_cache) {
    let funcs = list_create()

    let pos = 0
    while vexc_tok_kind(toks, pos) != 0 {
        // use "./file.vex" (top-level include; merges functions into this program)
        if vexc_tok_kind(toks, pos) == 41 {
            let pos = pos + 1
            if vexc_tok_kind(toks, pos) != 3 {
                vexc_error_at(toks, pos, path, "use expects a string path")
                let pos = pos + 1
                continue
            }

            let raw_path = vexc_strip_quotes(vexc_tok_text(toks, pos))
            let pos = pos + 1

            let full_path = raw_path
            let base_dir = vexc_path_dirname(path)
            if str_len(base_dir) != 0 {
                let full_path = path_join(base_dir, raw_path)
            }

            if env_find(imports_seen, full_path) == 0 {
                env_set(imports_seen, full_path, 1)
                let toks2 = vexc_tokenize_cached(full_path, token_cache)
                let prog2 = vexc_parse_program_with_imports(toks2, full_path, imports_seen, token_cache)
                vexc_list_extend(funcs, list_get(prog2, 1))
            }
            continue
        }

        let is_accel = 0
        if vexc_tok_kind(toks, pos) == 10 {
            let is_accel = 1
            let accel_pos = pos
            let pos = pos + 1
            if vexc_tok_kind(toks, pos) != 6 {
                vexc_error_at(toks, accel_pos, path, "@accel must precede fn")
            }
        }

        if vexc_tok_kind(toks, pos) == 6 {
            let fr = vexc_parse_func(toks, pos, is_accel, path)
            list_push(funcs, vexc_pair_node(fr))
            let pos = vexc_pair_pos(fr)
        }

        if vexc_tok_kind(toks, pos) != 6 {
            let pos = pos + 1
        }
    }

    let prog = list_create()
    list_push(prog, 100)
    list_push(prog, funcs)
    return prog
}

fn vexc_parse_program(toks, pos) {
    let imports_seen = env_create(0)
    let token_cache = vexc_token_cache_create()
    return vexc_parse_program_with_imports(toks, "", imports_seen, token_cache)
}

fn vexc_parse_program_file_cached(path, token_cache) {
    let imports_seen = env_create(0)
    env_set(imports_seen, path, 1)
    let toks = vexc_tokenize_cached(path, token_cache)
    return vexc_parse_program_with_imports(toks, path, imports_seen, token_cache)
}

fn vexc_parse_program_file(path) {
    let token_cache = vexc_token_cache_create()
    return vexc_parse_program_file_cached(path, token_cache)
}
