// src/compiler_core.vex
// Runnable "Day 1" self-hosting step: a Vex-written lexer that runs under the Zig bootstrap.

fn consume_digits(src, i) {
    let n = str_len(src)
    while i < n {
        let c = str_char(src, i)
        if c < 48 { return i }
        if c < 58 { let i = i + 1 }
        if 57 < c { return i }
    }
    return i
}

fn consume_ident(src, i) {
    let n = str_len(src)
    while i < n {
        let c = str_char(src, i)
        let ok = 0
        if c == 95 { let ok = 1 }
        if ok == 0 and 47 < c and c < 58 { let ok = 1 }
        if ok == 0 and 64 < c and c < 91 { let ok = 1 }
        if ok == 0 and 96 < c and c < 123 { let ok = 1 }
        if ok == 0 { return i }
        let i = i + 1
    }
    return i
}

fn skip_line_comment(src, i) {
    while i < str_len(src) {
        if str_char(src, i) == 10 { return i + 1 }
        let i = i + 1
    }
    return i
}

fn str_eq(a, b) {
    if str_len(a) != str_len(b) { return 0 }
    let i = 0
    while i < str_len(a) {
        if str_char(a, i) != str_char(b, i) { return 0 }
        let i = i + 1
    }
    return 1
}

fn kind_name(k) {
    if k == 0 { return "Eof" }
    if k == 1 { return "Ident" }
    if k == 2 { return "Int" }
    if k == 3 { return "String" }
    if k == 4 { return "Let" }
    if k == 5 { return "Print" }
    if k == 6 { return "Fn" }
    if k == 7 { return "Return" }
    if k == 8 { return "If" }
    if k == 9 { return "While" }
    if k == 10 { return "Accel" }
    if k == 11 { return "LParen" }
    if k == 12 { return "RParen" }
    if k == 13 { return "LBrace" }
    if k == 14 { return "RBrace" }
    if k == 15 { return "Equal" }
    if k == 16 { return "EqEq" }
    if k == 17 { return "BangEq" }
    if k == 18 { return "Plus" }
    if k == 30 { return "PlusEq" }
    if k == 19 { return "Minus" }
    if k == 20 { return "Star" }
    if k == 21 { return "Slash" }
    if k == 22 { return "Less" }
    if k == 23 { return "LessEq" }
    if k == 24 { return "And" }
    if k == 25 { return "Or" }
    if k == 26 { return "Greater" }
    if k == 27 { return "GreaterEq" }
    if k == 28 { return "Else" }
    if k == 29 { return "Dot" }
    if k == 31 { return "True" }
    if k == 32 { return "False" }
    if k == 33 { return "Null" }
    if k == 34 { return "For" }
    if k == 35 { return "In" }
    if k == 36 { return "DotDot" }
    if k == 37 { return "LBracket" }
    if k == 38 { return "RBracket" }
    return "Unknown"
}

fn tokenize(src) {
    let toks = list_create()

    let i = 0
    let n = str_len(src)
    while i < n {
        let c = str_char(src, i)
        let handled = 0

        // whitespace (control + space)
        if handled == 0 and c < 33 {
            let i = i + 1
            let handled = 1
        }

        // line comments: // ...
        if handled == 0 and c == 47 and (i + 1) < n and str_char(src, i + 1) == 47 {
            let i = skip_line_comment(src, i + 2)
            let handled = 1
        }

        // strings: " ... "
        if handled == 0 and c == 34 {
            let start = i
            let i = i + 1
            while i < n and str_char(src, i) != 34 {
                let i = i + 1
            }
            if i < n { let i = i + 1 }
            list_push(toks, 3)
            list_push(toks, str_slice(src, start, i))
            let handled = 1
        }

        // numbers
        if handled == 0 and 47 < c and c < 58 {
            let start = i
            let i = consume_digits(src, i)
            list_push(toks, 2)
            list_push(toks, str_slice(src, start, i))
            let handled = 1
        }

        // identifiers / keywords
        if handled == 0 and (c == 95 or (64 < c and c < 91) or (96 < c and c < 123)) {
            let start = i
            let i = consume_ident(src, i)
            let len = i - start

            let kind = 1
            if len == 2 {
                if str_char(src, start + 0) == 102 and str_char(src, start + 1) == 110 { let kind = 6 } // fn
                if str_char(src, start + 0) == 105 and str_char(src, start + 1) == 102 { let kind = 8 } // if
                if str_char(src, start + 0) == 111 and str_char(src, start + 1) == 114 { let kind = 25 } // or
                if str_char(src, start + 0) == 105 and str_char(src, start + 1) == 110 { let kind = 35 } // in
            }
        if kind == 1 and len == 3 {
            if str_char(src, start + 0) == 108 and str_char(src, start + 1) == 101 and str_char(src, start + 2) == 116 { let kind = 4 } // let
            if str_char(src, start + 0) == 97 and str_char(src, start + 1) == 110 and str_char(src, start + 2) == 100 { let kind = 24 } // and
            if str_char(src, start + 0) == 102 and str_char(src, start + 1) == 111 and str_char(src, start + 2) == 114 { let kind = 34 } // for
        }
        if kind == 1 and len == 4 {
            if str_char(src, start + 0) == 101 and str_char(src, start + 1) == 108 and str_char(src, start + 2) == 115 and str_char(src, start + 3) == 101 { let kind = 28 } // else
            if str_char(src, start + 0) == 116 and str_char(src, start + 1) == 114 and str_char(src, start + 2) == 117 and str_char(src, start + 3) == 101 { let kind = 31 } // true
            if str_char(src, start + 0) == 110 and str_char(src, start + 1) == 117 and str_char(src, start + 2) == 108 and str_char(src, start + 3) == 108 { let kind = 33 } // null
        }
        if kind == 1 and len == 5 {
            if str_char(src, start + 0) == 112 and str_char(src, start + 1) == 114 and str_char(src, start + 2) == 105 and str_char(src, start + 3) == 110 and str_char(src, start + 4) == 116 { let kind = 5 } // print
            if str_char(src, start + 0) == 119 and str_char(src, start + 1) == 104 and str_char(src, start + 2) == 105 and str_char(src, start + 3) == 108 and str_char(src, start + 4) == 101 { let kind = 9 } // while
            if str_char(src, start + 0) == 97 and str_char(src, start + 1) == 99 and str_char(src, start + 2) == 99 and str_char(src, start + 3) == 101 and str_char(src, start + 4) == 108 { let kind = 10 } // accel
            if str_char(src, start + 0) == 102 and str_char(src, start + 1) == 97 and str_char(src, start + 2) == 108 and str_char(src, start + 3) == 115 and str_char(src, start + 4) == 101 { let kind = 32 } // false
        }
            if kind == 1 and len == 6 {
                if str_char(src, start + 0) == 114 and str_char(src, start + 1) == 101 and str_char(src, start + 2) == 116 and str_char(src, start + 3) == 117 and str_char(src, start + 4) == 114 and str_char(src, start + 5) == 110 { let kind = 7 } // return
            }

            list_push(toks, kind)
            list_push(toks, str_slice(src, start, i))
            let handled = 1
        }

        // single/double-char tokens
        if handled == 0 and c == 40 { list_push(toks, 11); list_push(toks, "("); let i = i + 1; let handled = 1 }
        if handled == 0 and c == 41 { list_push(toks, 12); list_push(toks, ")"); let i = i + 1; let handled = 1 }
        if handled == 0 and c == 123 { list_push(toks, 13); list_push(toks, "{"); let i = i + 1; let handled = 1 }
        if handled == 0 and c == 125 { list_push(toks, 14); list_push(toks, "}"); let i = i + 1; let handled = 1 }
        if handled == 0 and c == 91 { list_push(toks, 37); list_push(toks, "["); let i = i + 1; let handled = 1 }
        if handled == 0 and c == 93 { list_push(toks, 38); list_push(toks, "]"); let i = i + 1; let handled = 1 }
        if handled == 0 and c == 46 {
            let is_dd = 0
            if (i + 1) < n and str_char(src, i + 1) == 46 { let is_dd = 1 }

            if is_dd == 1 {
                list_push(toks, 36)
                list_push(toks, "..")
                let i = i + 2
            }
            if is_dd == 0 {
                list_push(toks, 29)
                list_push(toks, ".")
                let i = i + 1
            }
            let handled = 1
        }

        if handled == 0 and c == 43 {
            let is_peq = 0
            if (i + 1) < n and str_char(src, i + 1) == 61 { let is_peq = 1 }

            if is_peq == 1 {
                list_push(toks, 30)
                list_push(toks, "+=")
                let i = i + 2
            }
            if is_peq == 0 {
                list_push(toks, 18)
                list_push(toks, "+")
                let i = i + 1
            }
            let handled = 1
        }
        if handled == 0 and c == 45 { list_push(toks, 19); list_push(toks, "-"); let i = i + 1; let handled = 1 }
        if handled == 0 and c == 42 { list_push(toks, 20); list_push(toks, "*"); let i = i + 1; let handled = 1 }
        if handled == 0 and c == 47 { list_push(toks, 21); list_push(toks, "/"); let i = i + 1; let handled = 1 }

        if handled == 0 and c == 60 {
            let is_le = 0
            if (i + 1) < n {
                if str_char(src, i + 1) == 61 { let is_le = 1 }
            }

            if is_le == 1 {
                list_push(toks, 23)
                list_push(toks, "<=")
                let i = i + 2
            }
            if is_le == 0 {
                list_push(toks, 22)
                list_push(toks, "<")
                let i = i + 1
            }
            let handled = 1
        }

        if handled == 0 and c == 62 {
            let is_ge = 0
            if (i + 1) < n {
                if str_char(src, i + 1) == 61 { let is_ge = 1 }
            }

            if is_ge == 1 {
                list_push(toks, 27)
                list_push(toks, ">=")
                let i = i + 2
            }
            if is_ge == 0 {
                list_push(toks, 26)
                list_push(toks, ">")
                let i = i + 1
            }
            let handled = 1
        }

        if handled == 0 and c == 61 {
            let is_eqeq = 0
            if (i + 1) < n {
                if str_char(src, i + 1) == 61 { let is_eqeq = 1 }
            }

            if is_eqeq == 1 {
                list_push(toks, 16)
                list_push(toks, "==")
                let i = i + 2
            }
            if is_eqeq == 0 {
                list_push(toks, 15)
                list_push(toks, "=")
                let i = i + 1
            }
            let handled = 1
        }

        if handled == 0 and c == 33 {
            if (i + 1) < n and str_char(src, i + 1) == 61 {
                list_push(toks, 17)
                list_push(toks, "!=")
                let i = i + 2
                let handled = 1
            }
        }

        // unknown char: skip
        if handled == 0 { let i = i + 1 }
    }

    list_push(toks, 0)
    list_push(toks, "")
    return toks
}

fn dump_tokens(toks, max) {
    let limit = list_len(toks)
    let max_entries = max * 2
    if max_entries < limit { let limit = max_entries }

    let i = 0
    while i < limit {
        let k = list_get(toks, i)
        let txt = list_get(toks, i + 1)
        print("tok:{kind_name(k)}:{txt}\n")
        let i = i + 2
    }
}

fn pair(a, b) {
    let p = list_create()
    list_push(p, a)
    list_push(p, b)
    return p
}

fn pair_node(p) { return list_get(p, 0) }
fn pair_pos(p) { return list_get(p, 1) }

fn tok_kind(toks, pos) {
    let idx = pos * 2
    if idx < list_len(toks) { return list_get(toks, idx) }
    return 0
}

fn tok_text(toks, pos) {
    let idx = pos * 2 + 1
    if idx < list_len(toks) { return list_get(toks, idx) }
    return ""
}

fn parse_int(s) {
    let v = 0
    let i = 0
    let n = str_len(s)
    while i < n {
        let c = str_char(s, i)
        if c < 48 { return v }
        if 57 < c { return v }
        let v = v * 10 + (c - 48)
        let i = i + 1
    }
    return v
}

fn strip_quotes(s) {
    let n = str_len(s)
    if n < 2 { return s }
    if str_char(s, 0) == 34 and str_char(s, n - 1) == 34 {
        return str_slice(s, 1, n - 1)
    }
    return s
}

// --- AST tags ---
// Program: [100, funcs]
// Func:    [101, name, p1, p2, p3, is_accel, body_block, params]
// Block:   [102, stmts]
// Stmts:   let [200, name, expr]
//          print [201, expr]
//          return [202, expr_or_0]
//          if [203, cond, then_block, else_block_or_0]
//          while [204, cond, body_block]
//          assign [206, op_kind, name, expr] // op_kind: Equal or PlusEq
//          for [207, name, start_expr, end_expr, body_block]
//          expr [205, expr]
// Exprs:   int [300, value]
//          str [301, value]
//          name [302, ident]
//          bin [303, op_kind, left, right]
//          call [304, callee, args]

fn make_block(stmts) {
    let b = list_create()
    list_push(b, 102)
    list_push(b, stmts)
    return b
}

fn parse_primary(toks, pos) {
    let k = tok_kind(toks, pos)

    if k == 31 {
        let node = list_create()
        list_push(node, 300)
        list_push(node, 1)
        return pair(node, pos + 1)
    }
    if k == 32 {
        let node = list_create()
        list_push(node, 300)
        list_push(node, 0)
        return pair(node, pos + 1)
    }
    if k == 33 {
        let node = list_create()
        list_push(node, 300)
        list_push(node, 0)
        return pair(node, pos + 1)
    }

    if k == 2 {
        let txt = tok_text(toks, pos)
        let node = list_create()
        list_push(node, 300)
        list_push(node, parse_int(txt))
        return pair(node, pos + 1)
    }

    if k == 3 {
        let raw = tok_text(toks, pos)
        let node = list_create()
        list_push(node, 301)
        list_push(node, strip_quotes(raw))
        return pair(node, pos + 1)
    }

    if k == 29 {
        if tok_kind(toks, pos + 1) == 1 {
            let node = list_create()
            list_push(node, 301)
            list_push(node, tok_text(toks, pos + 1))
            return pair(node, pos + 2)
        }
    }

    if k == 1 {
        let name = tok_text(toks, pos)
        if tok_kind(toks, pos + 1) == 11 {
            let pos = pos + 2
            let args = list_create()
            while tok_kind(toks, pos) != 12 and tok_kind(toks, pos) != 0 {
                let r = parse_expr(toks, pos)
                list_push(args, pair_node(r))
                let pos = pair_pos(r)
            }
            if tok_kind(toks, pos) == 12 { let pos = pos + 1 }

            let node = list_create()
            list_push(node, 304)
            list_push(node, name)
            list_push(node, args)
            return pair(node, pos)
        }

        let node = list_create()
        list_push(node, 302)
        list_push(node, name)
        return pair(node, pos + 1)
    }

    if k == 11 {
        let r = parse_expr(toks, pos + 1)
        let expr = pair_node(r)
        let pos = pair_pos(r)
        if tok_kind(toks, pos) == 12 { let pos = pos + 1 }
        return pair(expr, pos)
    }

    let node = list_create()
    list_push(node, 302)
    list_push(node, "")
    return pair(node, pos + 1)
}

fn parse_postfix(toks, pos) {
    let r = parse_primary(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let did = 0

        // member access: obj.field -> env_find(obj, "field")
        if tok_kind(toks, pos) == 29 and tok_kind(toks, pos + 1) == 1 {
            let field = tok_text(toks, pos + 1)
            let pos = pos + 2

            let args = list_create()
            list_push(args, lhs)

            let key = list_create()
            list_push(key, 301)
            list_push(key, field)
            list_push(args, key)

            let node = list_create()
            list_push(node, 304)
            list_push(node, "env_find")
            list_push(node, args)
            let lhs = node
            let did = 1
        }

        // indexing: xs[i] -> list_get(xs, i)
        if did == 0 and tok_kind(toks, pos) == 37 {
            let r2 = parse_expr(toks, pos + 1)
            let idx_expr = pair_node(r2)
            let pos = pair_pos(r2)
            if tok_kind(toks, pos) == 38 { let pos = pos + 1 }

            let args = list_create()
            list_push(args, lhs)
            list_push(args, idx_expr)

            let node = list_create()
            list_push(node, 304)
            list_push(node, "list_get")
            list_push(node, args)
            let lhs = node
            let did = 1
        }

        if did == 0 { return pair(lhs, pos) }
    }
    return pair(lhs, pos)
}

fn parse_term(toks, pos) {
    let r = parse_postfix(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        let is_op = 0
        if k == 20 { let is_op = 1 }
        if k == 21 { let is_op = 1 }
        if is_op == 0 { return pair(lhs, pos) }

        let op = k
        let r2 = parse_postfix(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, op)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_add(toks, pos) {
    let r = parse_term(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        let is_op = 0
        if k == 18 { let is_op = 1 }
        if k == 19 { let is_op = 1 }
        if is_op == 0 { return pair(lhs, pos) }

        let op = k
        let r2 = parse_term(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, op)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_compare(toks, pos) {
    let r = parse_add(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        let is_op = 0
        if k == 22 { let is_op = 1 }
        if k == 23 { let is_op = 1 }
        if k == 26 { let is_op = 1 }
        if k == 27 { let is_op = 1 }
        if is_op == 0 { return pair(lhs, pos) }

        let op = k
        let r2 = parse_add(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, op)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_eq(toks, pos) {
    let r = parse_compare(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        let is_op = 0
        if k == 16 { let is_op = 1 }
        if k == 17 { let is_op = 1 }
        if is_op == 0 { return pair(lhs, pos) }

        let op = k
        let r2 = parse_compare(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, op)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_and(toks, pos) {
    let r = parse_eq(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        if k != 24 { return pair(lhs, pos) }

        let r2 = parse_eq(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, k)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_or(toks, pos) {
    let r = parse_and(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        if k != 25 { return pair(lhs, pos) }

        let r2 = parse_and(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, k)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_expr(toks, pos) {
    return parse_or(toks, pos)
}

fn parse_block(toks, pos) {
    let stmts = list_create()
    if tok_kind(toks, pos) == 13 { let pos = pos + 1 }

    while tok_kind(toks, pos) != 14 and tok_kind(toks, pos) != 0 {
        let r = parse_stmt(toks, pos)
        list_push(stmts, pair_node(r))
        let pos = pair_pos(r)
    }

    if tok_kind(toks, pos) == 14 { let pos = pos + 1 }
    return pair(make_block(stmts), pos)
}

fn parse_stmt(toks, pos) {
    let k = tok_kind(toks, pos)

    // let name = expr
    if k == 4 {
        let name = ""
        if tok_kind(toks, pos + 1) == 1 { let name = tok_text(toks, pos + 1) }

        let pos = pos + 1
        if tok_kind(toks, pos) == 1 { let pos = pos + 1 }
        while tok_kind(toks, pos) != 15 and tok_kind(toks, pos) != 0 { let pos = pos + 1 }
        if tok_kind(toks, pos) == 15 { let pos = pos + 1 }

        let r = parse_expr(toks, pos)
        let expr = pair_node(r)
        let pos = pair_pos(r)

        let node = list_create()
        list_push(node, 200)
        list_push(node, name)
        list_push(node, expr)
        return pair(node, pos)
    }

    // print(expr)
    if k == 5 {
        let pos = pos + 1
        if tok_kind(toks, pos) == 11 { let pos = pos + 1 }

        let r = parse_expr(toks, pos)
        let expr = pair_node(r)
        let pos = pair_pos(r)

        if tok_kind(toks, pos) == 12 { let pos = pos + 1 }

        let node = list_create()
        list_push(node, 201)
        list_push(node, expr)
        return pair(node, pos)
    }

    // return expr?
    if k == 7 {
        let pos = pos + 1
        let expr = 0
        let next = tok_kind(toks, pos)
        if next != 14 and next != 0 {
            let r = parse_expr(toks, pos)
            let expr = pair_node(r)
            let pos = pair_pos(r)
        }

        let node = list_create()
        list_push(node, 202)
        list_push(node, expr)
        return pair(node, pos)
    }

    // if cond { ... } or if cond stmt
    if k == 8 {
        let pos = pos + 1
        let r = parse_expr(toks, pos)
        let cond = pair_node(r)
        let pos = pair_pos(r)

        let then_block = 0
        let did_then = 0
        if tok_kind(toks, pos) == 13 {
            let br = parse_block(toks, pos)
            let then_block = pair_node(br)
            let pos = pair_pos(br)
            let did_then = 1
        }
        if did_then == 0 {
            let sr = parse_stmt(toks, pos)
            let inner = pair_node(sr)
            let pos = pair_pos(sr)
            let stmts = list_create()
            list_push(stmts, inner)
            let then_block = make_block(stmts)
        }

        let else_block = 0
        if tok_kind(toks, pos) == 28 {
            let pos = pos + 1

            let did_else = 0
            if tok_kind(toks, pos) == 13 {
                let br = parse_block(toks, pos)
                let else_block = pair_node(br)
                let pos = pair_pos(br)
                let did_else = 1
            }
            if did_else == 0 {
                let sr = parse_stmt(toks, pos)
                let inner = pair_node(sr)
                let pos = pair_pos(sr)
                let stmts = list_create()
                list_push(stmts, inner)
                let else_block = make_block(stmts)
            }
        }

        let node = list_create()
        list_push(node, 203)
        list_push(node, cond)
        list_push(node, then_block)
        list_push(node, else_block)
        return pair(node, pos)
    }

    // while cond { ... }
    if k == 9 {
        let pos = pos + 1
        let r = parse_expr(toks, pos)
        let cond = pair_node(r)
        let pos = pair_pos(r)

        let body = 0
        if tok_kind(toks, pos) == 13 {
            let br = parse_block(toks, pos)
            let body = pair_node(br)
            let pos = pair_pos(br)

            let node = list_create()
            list_push(node, 204)
            list_push(node, cond)
            list_push(node, body)
            return pair(node, pos)
        }

        let sr = parse_stmt(toks, pos)
        let inner = pair_node(sr)
        let pos = pair_pos(sr)
        let stmts = list_create()
        list_push(stmts, inner)
        let body = make_block(stmts)

        let node = list_create()
        list_push(node, 204)
        list_push(node, cond)
        list_push(node, body)
        return pair(node, pos)
    }

    // for name in start..end { ... }
    if k == 34 {
        let pos = pos + 1
        let name = ""
        if tok_kind(toks, pos) == 1 { let name = tok_text(toks, pos) }

        if tok_kind(toks, pos) == 1 { let pos = pos + 1 }
        if tok_kind(toks, pos) == 35 { let pos = pos + 1 }

        let r1 = parse_expr(toks, pos)
        let start_expr = pair_node(r1)
        let pos = pair_pos(r1)

        if tok_kind(toks, pos) == 36 { let pos = pos + 1 }

        let r2 = parse_expr(toks, pos)
        let end_expr = pair_node(r2)
        let pos = pair_pos(r2)

        let body = 0
        if tok_kind(toks, pos) == 13 {
            let br = parse_block(toks, pos)
            let body = pair_node(br)
            let pos = pair_pos(br)
        }
        if body == 0 {
            let sr = parse_stmt(toks, pos)
            let inner = pair_node(sr)
            let pos = pair_pos(sr)
            let stmts = list_create()
            list_push(stmts, inner)
            let body = make_block(stmts)
        }

        let node = list_create()
        list_push(node, 207)
        list_push(node, name)
        list_push(node, start_expr)
        list_push(node, end_expr)
        list_push(node, body)
        return pair(node, pos)
    }

    // { ... }
    if k == 13 {
        let br = parse_block(toks, pos)
        let block = pair_node(br)
        let pos = pair_pos(br)
        return pair(block, pos)
    }

    // name = expr / name += expr
    if k == 1 {
        let name = tok_text(toks, pos)
        let op = tok_kind(toks, pos + 1)
        if op == 15 or op == 30 {
            let r = parse_expr(toks, pos + 2)
            let expr = pair_node(r)
            let pos = pair_pos(r)

            let node = list_create()
            list_push(node, 206)
            list_push(node, op)
            list_push(node, name)
            list_push(node, expr)
            return pair(node, pos)
        }
    }

    // Fallback: expression statement.
    let r = parse_expr(toks, pos)
    let expr = pair_node(r)
    let pos = pair_pos(r)

    let node = list_create()
    list_push(node, 205)
    list_push(node, expr)
    return pair(node, pos)
}

fn parse_func(toks, pos, is_accel) {
    // consume 'fn'
    if tok_kind(toks, pos) == 6 { let pos = pos + 1 }

    let name = tok_text(toks, pos)
    if tok_kind(toks, pos) == 1 { let pos = pos + 1 }

    let p1 = ""
    let p2 = ""
    let p3 = ""
    let params = list_create()
    let param_i = 0

    if tok_kind(toks, pos) == 11 {
        let pos = pos + 1
        while tok_kind(toks, pos) != 12 and tok_kind(toks, pos) != 0 {
            if tok_kind(toks, pos) == 1 {
                if param_i == 0 { let p1 = tok_text(toks, pos) }
                if param_i == 1 { let p2 = tok_text(toks, pos) }
                if param_i == 2 { let p3 = tok_text(toks, pos) }
                list_push(params, tok_text(toks, pos))
                let param_i = param_i + 1
            }
            let pos = pos + 1
        }
        if tok_kind(toks, pos) == 12 { let pos = pos + 1 }
    }

    while tok_kind(toks, pos) != 13 and tok_kind(toks, pos) != 0 { let pos = pos + 1 }
    let br = parse_block(toks, pos)
    let body = pair_node(br)
    let pos = pair_pos(br)

    let node = list_create()
    list_push(node, 101)
    list_push(node, name)
    list_push(node, p1)
    list_push(node, p2)
    list_push(node, p3)
    list_push(node, is_accel)
    list_push(node, body)
    list_push(node, params)
    return pair(node, pos)
}

fn parse_program(toks) {
    let funcs = list_create()
    let pos = 0

    while tok_kind(toks, pos) != 0 {
        let is_accel = 0
        if tok_kind(toks, pos) == 10 {
            let is_accel = 1
            let pos = pos + 1
        }

        if tok_kind(toks, pos) == 6 {
            let fr = parse_func(toks, pos, is_accel)
            list_push(funcs, pair_node(fr))
            let pos = pair_pos(fr)
        }

        if tok_kind(toks, pos) != 6 {
            let pos = pos + 1
        }
    }

    let prog = list_create()
    list_push(prog, 100)
    list_push(prog, funcs)
    return prog
}

// --- Eval (Vex-in-Vex execution) ---

fn ret_pair(did_return, value) {
    let r = list_create()
    list_push(r, did_return)
    list_push(r, value)
    return r
}

fn ret_did(r) { return list_get(r, 0) }
fn ret_val(r) { return list_get(r, 1) }

fn is_digit_char(c) {
    if 47 < c and c < 58 { return 1 }
    return 0
}

fn is_ident_char(c) {
    if c == 95 { return 1 }
    if 47 < c and c < 58 { return 1 }
    if 64 < c and c < 91 { return 1 }
    if 96 < c and c < 123 { return 1 }
    return 0
}

fn eval_expr(expr, func_env, vals_env, defs_env, prog_args) {
    let tag = list_get(expr, 0)

    if tag == 300 { return list_get(expr, 1) }
    if tag == 301 { return list_get(expr, 1) }
    if tag == 302 {
        let name = list_get(expr, 1)
        return env_find(vals_env, name)
    }

    if tag == 303 {
        let op = list_get(expr, 1)
        let lhs = eval_expr(list_get(expr, 2), func_env, vals_env, defs_env, prog_args)
        let rhs = eval_expr(list_get(expr, 3), func_env, vals_env, defs_env, prog_args)

        if op == 18 { return lhs + rhs }
        if op == 19 { return lhs - rhs }
        if op == 20 { return lhs * rhs }
        if op == 21 { return lhs / rhs }

        if op == 22 {
            let out = 0
            if lhs < rhs { let out = 1 }
            return out
        }
        if op == 23 {
            let out = 0
            if lhs <= rhs { let out = 1 }
            return out
        }
        if op == 26 {
            let out = 0
            if lhs > rhs { let out = 1 }
            return out
        }
        if op == 27 {
            let out = 0
            if lhs >= rhs { let out = 1 }
            return out
        }
        if op == 16 {
            let out = 0
            if lhs == rhs { let out = 1 }
            return out
        }
        if op == 17 {
            let out = 0
            if lhs != rhs { let out = 1 }
            return out
        }
        if op == 24 {
            let out = 0
            if lhs != 0 and rhs != 0 { let out = 1 }
            return out
        }
        if op == 25 {
            let out = 0
            if lhs != 0 or rhs != 0 { let out = 1 }
            return out
        }

        return 0
    }

    if tag == 304 {
        let name = list_get(expr, 1)
        let args = list_get(expr, 2)
        return eval_call_expr(name, args, func_env, vals_env, defs_env, prog_args)
    }

    return 0
}

fn eval_arg_expr(args, idx, func_env, vals_env, defs_env, prog_args) {
    let e = list_get(args, idx)
    if e == 0 { return 0 }
    return eval_expr(e, func_env, vals_env, defs_env, prog_args)
}

fn eval_user_func(func_node, a0, a1, a2, func_env, caller_vals, caller_defs, prog_args) {
    let p1 = list_get(func_node, 2)
    let p2 = list_get(func_node, 3)
    let p3 = list_get(func_node, 4)
    let body = list_get(func_node, 6)

    let vals = env_create(caller_vals)
    let defs = env_create(caller_defs)

    if str_len(p1) != 0 {
        env_set(vals, p1, a0)
        env_set(defs, p1, 1)
    }
    if str_len(p2) != 0 {
        env_set(vals, p2, a1)
        env_set(defs, p2, 1)
    }
    if str_len(p3) != 0 {
        env_set(vals, p3, a2)
        env_set(defs, p3, 1)
    }

    let r = eval_block(body, func_env, vals, defs, prog_args)
    if ret_did(r) != 0 { return ret_val(r) }
    return 0
}

fn call3(name, a0, a1, a2, argc, func_env, vals_env, defs_env, prog_args) {
    if str_eq(name, "env_create") { return env_create(a0) }
    if str_eq(name, "env_set") {
        env_set(a0, a1, a2)
        return 0
    }
    if str_eq(name, "env_find") { return env_find(a0, a1) }

    if str_eq(name, "str_len") { return str_len(a0) }
    if str_eq(name, "str_char") { return str_char(a0, a1) }
    if str_eq(name, "str_slice") { return str_slice(a0, a1, a2) }

    if str_eq(name, "print_bytes") {
        print_bytes(a0)
        return 0
    }
    if str_eq(name, "print_char") {
        print_char(a0)
        return 0
    }

    if str_eq(name, "list_create") { return list_create() }
    if str_eq(name, "list_push") {
        list_push(a0, a1)
        return 0
    }
    if str_eq(name, "list_len") { return list_len(a0) }
    if str_eq(name, "list_get") { return list_get(a0, a1) }

    if str_eq(name, "read_file") { return read_file(a0) }
    if str_eq(name, "write_file") {
        write_file(a0, a1)
        return 0
    }

    if str_eq(name, "arg_len") { return list_len(prog_args) }
    if str_eq(name, "arg_get") {
        let idx = a0
        let n = list_len(prog_args)
        if idx < 0 { return "" }
        if idx < n { return list_get(prog_args, idx) }
        return ""
    }

    let func_node = env_find(func_env, name)
    if func_node == 0 {
        print("[undefined function] {name}\n")
        return 0
    }

    return eval_user_func(func_node, a0, a1, a2, func_env, vals_env, defs_env, prog_args)
}

fn eval_call_expr(name, args, func_env, vals_env, defs_env, prog_args) {
    let argc = list_len(args)
    let use = argc
    if 3 < use { let use = 3 }

    let a0 = 0
    let a1 = 0
    let a2 = 0
    if 0 < use { let a0 = eval_arg_expr(args, 0, func_env, vals_env, defs_env, prog_args) }
    if 1 < use { let a1 = eval_arg_expr(args, 1, func_env, vals_env, defs_env, prog_args) }
    if 2 < use { let a2 = eval_arg_expr(args, 2, func_env, vals_env, defs_env, prog_args) }

    return call3(name, a0, a1, a2, use, func_env, vals_env, defs_env, prog_args)
}

fn render_string(func_env, vals_env, defs_env, prog_args, raw) {
    let i = 0
    let n = str_len(raw)
    while i < n {
        let c = str_char(raw, i)

        if c == 123 {
            let j = i + 1
            while j < n and str_char(raw, j) != 125 { let j = j + 1 }

            if j < n {
                let expr = str_slice(raw, i + 1, j)
                let k = 0
                let elen = str_len(expr)

                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }
                let start_name = k
                while k < elen and is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                let name = str_slice(expr, start_name, k)
                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }

                let did_call = 0

                // func call: {name(16)} or {name(x)}
                if k < elen and str_char(expr, k) == 40 {
                    let did_call = 1
                    let k = k + 1
                    while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }

                    let arg_val = 0
                    let parsed_num = 0

                    if k < elen and is_digit_char(str_char(expr, k)) != 0 {
                        let start = k
                        while k < elen and is_digit_char(str_char(expr, k)) != 0 { let k = k + 1 }
                        let arg_val = parse_int(str_slice(expr, start, k))
                        let parsed_num = 1
                    }

                    if parsed_num == 0 {
                        let start = k
                        while k < elen and is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                        let arg_name = str_slice(expr, start, k)
                        let arg_val = env_find(vals_env, arg_name)
                    }

                    let v = call3(name, arg_val, 0, 0, 1, func_env, vals_env, defs_env, prog_args)
                    print(v)
                }

                // variable: {x}
                if did_call == 0 {
                    let def = env_find(defs_env, name)
                    if def != 0 {
                        let v = env_find(vals_env, name)
                        print(v)
                    }
                    if def == 0 {
                        print_char(123)
                        print_bytes(name)
                        print_char(125)
                    }
                }

                let i = j + 1
            }

            if j >= n {
                print_char(123)
                let i = i + 1
            }
        }

        if c != 123 {
            let handled = 0
            if c == 92 and (i + 1) < n and str_char(raw, i + 1) == 110 {
                print_char(10)
                let i = i + 2
                let handled = 1
            }
            if handled == 0 {
                print_char(c)
                let i = i + 1
            }
        }
    }
    return 0
}

fn eval_stmt(stmt, func_env, vals_env, defs_env, prog_args) {
    let tag = list_get(stmt, 0)

    if tag == 102 { return eval_block(stmt, func_env, vals_env, defs_env, prog_args) }

    if tag == 200 {
        let name = list_get(stmt, 1)
        let expr = list_get(stmt, 2)
        let v = eval_expr(expr, func_env, vals_env, defs_env, prog_args)
        if str_len(name) != 0 {
            env_set(vals_env, name, v)
            env_set(defs_env, name, 1)
        }
        return ret_pair(0, 0)
    }

    if tag == 206 {
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        let expr = list_get(stmt, 3)
        let rhs = eval_expr(expr, func_env, vals_env, defs_env, prog_args)
        let out = rhs
        if op == 30 { let out = env_find(vals_env, name) + out }
        if str_len(name) != 0 {
            env_set(vals_env, name, out)
            env_set(defs_env, name, 1)
        }
        return ret_pair(0, 0)
    }

    if tag == 201 {
        let expr = list_get(stmt, 1)
        if list_get(expr, 0) == 301 {
            render_string(func_env, vals_env, defs_env, prog_args, list_get(expr, 1))
        }
        if list_get(expr, 0) != 301 {
            let v = eval_expr(expr, func_env, vals_env, defs_env, prog_args)
            print(v)
        }
        return ret_pair(0, 0)
    }

    if tag == 202 {
        let expr = list_get(stmt, 1)
        if expr == 0 { return ret_pair(1, 0) }
        let v = eval_expr(expr, func_env, vals_env, defs_env, prog_args)
        return ret_pair(1, v)
    }

    if tag == 203 {
        let cond = eval_expr(list_get(stmt, 1), func_env, vals_env, defs_env, prog_args)
        if cond != 0 {
            return eval_block(list_get(stmt, 2), func_env, vals_env, defs_env, prog_args)
        }
        let else_block = list_get(stmt, 3)
        if else_block != 0 {
            return eval_block(else_block, func_env, vals_env, defs_env, prog_args)
        }
        return ret_pair(0, 0)
    }

    if tag == 204 {
        let cond_expr = list_get(stmt, 1)
        let body = list_get(stmt, 2)
        while eval_expr(cond_expr, func_env, vals_env, defs_env, prog_args) != 0 {
            let r = eval_block(body, func_env, vals_env, defs_env, prog_args)
            if ret_did(r) != 0 { return r }
        }
        return ret_pair(0, 0)
    }

    if tag == 207 {
        let name = list_get(stmt, 1)
        let start = eval_expr(list_get(stmt, 2), func_env, vals_env, defs_env, prog_args)
        let end = eval_expr(list_get(stmt, 3), func_env, vals_env, defs_env, prog_args)
        let body = list_get(stmt, 4)
        while start < end {
            if str_len(name) != 0 {
                env_set(vals_env, name, start)
                env_set(defs_env, name, 1)
            }
            let r = eval_block(body, func_env, vals_env, defs_env, prog_args)
            if ret_did(r) != 0 { return r }
            let start = start + 1
        }
        return ret_pair(0, 0)
    }

    if tag == 205 {
        eval_expr(list_get(stmt, 1), func_env, vals_env, defs_env, prog_args)
        return ret_pair(0, 0)
    }

    return ret_pair(0, 0)
}

fn eval_block(block, func_env, vals_env, defs_env, prog_args) {
    let stmts = list_get(block, 1)
    let i = 0
    let n = list_len(stmts)
    while i < n {
        let s = list_get(stmts, i)
        let r = eval_stmt(s, func_env, vals_env, defs_env, prog_args)
        if ret_did(r) != 0 { return r }
        let i = i + 1
    }
    return ret_pair(0, 0)
}

fn eval_program(prog, prog_args) {
    let funcs = list_get(prog, 1)
    let func_env = env_create(0)

    let i = 0
    let n = list_len(funcs)
    while i < n {
        let f = list_get(funcs, i)
        env_set(func_env, list_get(f, 1), f)
        let i = i + 1
    }

    let vals = env_create(0)
    let defs = env_create(0)

    call3("main", 0, 0, 0, 0, func_env, vals, defs, prog_args)
    return 0
}

fn indent(depth) {
    let i = 0
    while i < depth {
        print_bytes("  ")
        let i = i + 1
    }
}

fn dump_expr(expr, depth, max_depth) {
    if depth > max_depth { return 0 }

    let tag = list_get(expr, 0)

    if tag == 300 {
        indent(depth)
        let v = list_get(expr, 1)
        print("Int {v}\n")
        return 0
    }
    if tag == 301 {
        indent(depth)
        let s = list_get(expr, 1)
        print("Str \"{s}\"\n")
        return 0
    }
    if tag == 302 {
        indent(depth)
        let name = list_get(expr, 1)
        print("Name {name}\n")
        return 0
    }
    if tag == 304 {
        indent(depth)
        let callee = list_get(expr, 1)
        let args = list_get(expr, 2)
        let argc = list_len(args)
        print("Call {callee} argc={argc}\n")
        let i = 0
        while i < argc {
            dump_expr(list_get(args, i), depth + 1, max_depth)
            let i = i + 1
        }
        return 0
    }
    if tag == 303 {
        indent(depth)
        let op = list_get(expr, 1)
        print("Bin {kind_name(op)}\n")
        dump_expr(list_get(expr, 2), depth + 1, max_depth)
        dump_expr(list_get(expr, 3), depth + 1, max_depth)
        return 0
    }

    indent(depth)
    print("Expr?\n")
    return 0
}

fn dump_stmt(stmt, depth, max_depth) {
    if depth > max_depth { return 0 }

    let tag = list_get(stmt, 0)

    if tag == 200 {
        indent(depth)
        let name = list_get(stmt, 1)
        print("Let {name}\n")
        dump_expr(list_get(stmt, 2), depth + 1, max_depth)
        return 0
    }
    if tag == 206 {
        indent(depth)
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        if op == 30 { print("AddAssign {name}\n") }
        if op != 30 { print("Assign {name}\n") }
        dump_expr(list_get(stmt, 3), depth + 1, max_depth)
        return 0
    }
    if tag == 201 {
        indent(depth)
        print("Print\n")
        dump_expr(list_get(stmt, 1), depth + 1, max_depth)
        return 0
    }
    if tag == 202 {
        indent(depth)
        print("Return\n")
        let e = list_get(stmt, 1)
        if e != 0 { dump_expr(e, depth + 1, max_depth) }
        return 0
    }
    if tag == 203 {
        indent(depth)
        print("If\n")
        dump_expr(list_get(stmt, 1), depth + 1, max_depth)
        dump_block(list_get(stmt, 2), depth + 1, max_depth)
        let else_block = list_get(stmt, 3)
        if else_block != 0 {
            indent(depth)
            print("Else\n")
            dump_block(else_block, depth + 1, max_depth)
        }
        return 0
    }
    if tag == 204 {
        indent(depth)
        print("While\n")
        dump_expr(list_get(stmt, 1), depth + 1, max_depth)
        dump_block(list_get(stmt, 2), depth + 1, max_depth)
        return 0
    }
    if tag == 207 {
        indent(depth)
        let name = list_get(stmt, 1)
        print("For {name}\n")
        dump_expr(list_get(stmt, 2), depth + 1, max_depth)
        dump_expr(list_get(stmt, 3), depth + 1, max_depth)
        dump_block(list_get(stmt, 4), depth + 1, max_depth)
        return 0
    }
    if tag == 205 {
        indent(depth)
        print("ExprStmt\n")
        dump_expr(list_get(stmt, 1), depth + 1, max_depth)
        return 0
    }
    if tag == 102 {
        dump_block(stmt, depth, max_depth)
        return 0
    }

    indent(depth)
    print("Stmt?\n")
    return 0
}

fn dump_block(block, depth, max_depth) {
    if depth > max_depth { return 0 }

    indent(depth)
    print("Block\n")

    let stmts = list_get(block, 1)
    let n = list_len(stmts)
    let i = 0
    while i < n {
        dump_stmt(list_get(stmts, i), depth + 1, max_depth)
        let i = i + 1
    }
    return 0
}

fn dump_program_summary(prog) {
    let funcs = list_get(prog, 1)
    let n = list_len(funcs)
    print("functions: {n}\n")

    let i = 0
    while i < n {
        let f = list_get(funcs, i)
        let name = list_get(f, 1)
        let is_accel = list_get(f, 5)
        let body = list_get(f, 6)
        let stmts = list_get(body, 1)
        let stmt_count = list_len(stmts)
        print("fn {name} accel={is_accel} stmts={stmt_count}\n")
        let i = i + 1
    }
    return 0
}

fn dump_program_tree(prog) {
    let funcs = list_get(prog, 1)
    let n = list_len(funcs)
    print("Program\n")

    let i = 0
    while i < n {
        let f = list_get(funcs, i)
        let name = list_get(f, 1)
        let is_accel = list_get(f, 5)
        indent(1)
        print("Fn {name} accel={is_accel}\n")
        dump_block(list_get(f, 6), 2, 8)
        let i = i + 1
    }
    return 0
}

// --- Vex-in-Vex execution (Core AST evaluator) ---

fn ceval_ret_pair(did_return, value) {
    let r = list_create()
    list_push(r, did_return)
    list_push(r, value)
    return r
}

fn ceval_ret_did(r) { return list_get(r, 0) }
fn ceval_ret_val(r) { return list_get(r, 1) }

fn ceval_env_vals(envs) { return list_get(envs, 0) }
fn ceval_env_defs(envs) { return list_get(envs, 1) }

fn ceval_user_func(func_node, args, caller_envs) {
    let parent_vals = ceval_env_vals(caller_envs)
    let parent_defs = ceval_env_defs(caller_envs)

    let vals = env_create(parent_vals)
    let defs = env_create(parent_defs)

    let params = list_get(func_node, 7)
    if params == 0 {
        let p1 = list_get(func_node, 2)
        let p2 = list_get(func_node, 3)
        let p3 = list_get(func_node, 4)

        let a0 = list_get(args, 0)
        let a1 = list_get(args, 1)
        let a2 = list_get(args, 2)

        if str_len(p1) != 0 {
            env_set(vals, p1, a0)
            env_set(defs, p1, 1)
        }
        if str_len(p2) != 0 {
            env_set(vals, p2, a1)
            env_set(defs, p2, 1)
        }
        if str_len(p3) != 0 {
            env_set(vals, p3, a2)
            env_set(defs, p3, 1)
        }
    }
    if params != 0 {
        let i = 0
        let n = list_len(params)
        while i < n {
            let p = list_get(params, i)
            if str_len(p) != 0 {
                env_set(vals, p, list_get(args, i))
                env_set(defs, p, 1)
            }
            let i = i + 1
        }
    }

    let envs = pair(vals, defs)
    let r = ceval_block(list_get(func_node, 6), envs)
    if ceval_ret_did(r) != 0 { return ceval_ret_val(r) }
    return 0
}

fn ceval_call_value(name, args, envs) {
    // Builtins
    if str_eq(name, "env_create") { return env_create(list_get(args, 0)) }
    if str_eq(name, "env_set") {
        env_set(list_get(args, 0), list_get(args, 1), list_get(args, 2))
        return 0
    }
    if str_eq(name, "env_find") { return env_find(list_get(args, 0), list_get(args, 1)) }

    if str_eq(name, "str_len") { return str_len(list_get(args, 0)) }
    if str_eq(name, "str_char") { return str_char(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "str_slice") { return str_slice(list_get(args, 0), list_get(args, 1), list_get(args, 2)) }

    if str_eq(name, "print_bytes") {
        print_bytes(list_get(args, 0))
        return 0
    }
    if str_eq(name, "print_char") {
        print_char(list_get(args, 0))
        return 0
    }

    if str_eq(name, "list_create") { return list_create() }
    if str_eq(name, "list_push") {
        list_push(list_get(args, 0), list_get(args, 1))
        return 0
    }
    if str_eq(name, "list_len") { return list_len(list_get(args, 0)) }
    if str_eq(name, "list_get") { return list_get(list_get(args, 0), list_get(args, 1)) }

    if str_eq(name, "read_file") { return read_file(list_get(args, 0)) }
    if str_eq(name, "write_file") {
        write_file(list_get(args, 0), list_get(args, 1))
        return 0
    }

    // Program args (provided by `ceval_program`)
    if str_eq(name, "arg_len") { return list_len(ceval_args) }
    if str_eq(name, "arg_get") {
        let idx = list_get(args, 0)
        let n = list_len(ceval_args)
        if idx < 0 { return "" }
        if idx < n { return list_get(ceval_args, idx) }
        return ""
    }

    // User-defined
    let func_node = env_find(ceval_funcs, name)
    if func_node == 0 {
        print("[undefined function] {name}\n")
        return 0
    }
    return ceval_user_func(func_node, args, envs)
}

fn ceval_call(call_expr, envs) {
    let name = list_get(call_expr, 1)
    let arg_exprs = list_get(call_expr, 2)

    let args = list_create()
    let i = 0
    let n = list_len(arg_exprs)
    while i < n {
        list_push(args, ceval_expr(list_get(arg_exprs, i), envs))
        let i = i + 1
    }
    return ceval_call_value(name, args, envs)
}

fn ceval_expr(expr, envs) {
    let tag = list_get(expr, 0)

    if tag == 300 { return list_get(expr, 1) }
    if tag == 301 { return list_get(expr, 1) }
    if tag == 302 { return env_find(ceval_env_vals(envs), list_get(expr, 1)) }

    if tag == 303 {
        let op = list_get(expr, 1)
        let lhs = ceval_expr(list_get(expr, 2), envs)
        let rhs = ceval_expr(list_get(expr, 3), envs)

        if op == 18 { return lhs + rhs }
        if op == 19 { return lhs - rhs }
        if op == 20 { return lhs * rhs }
        if op == 21 { return lhs / rhs }

        if op == 22 {
            let out = 0
            if lhs < rhs { let out = 1 }
            return out
        }
        if op == 23 {
            let out = 0
            if lhs <= rhs { let out = 1 }
            return out
        }
        if op == 26 {
            let out = 0
            if lhs > rhs { let out = 1 }
            return out
        }
        if op == 27 {
            let out = 0
            if lhs >= rhs { let out = 1 }
            return out
        }
        if op == 16 {
            let out = 0
            if lhs == rhs { let out = 1 }
            return out
        }
        if op == 17 {
            let out = 0
            if lhs != rhs { let out = 1 }
            return out
        }
        if op == 24 {
            let out = 0
            if lhs != 0 and rhs != 0 { let out = 1 }
            return out
        }
        if op == 25 {
            let out = 0
            if lhs != 0 or rhs != 0 { let out = 1 }
            return out
        }

        return 0
    }

    if tag == 304 { return ceval_call(expr, envs) }
    return 0
}

fn ceval_render_string(raw, envs) {
    let vals_env = ceval_env_vals(envs)
    let defs_env = ceval_env_defs(envs)

    let i = 0
    let n = str_len(raw)
    while i < n {
        let c = str_char(raw, i)

        if c == 123 {
            let j = i + 1
            while j < n and str_char(raw, j) != 125 { let j = j + 1 }

            if j < n {
                let expr = str_slice(raw, i + 1, j)
                let k = 0
                let elen = str_len(expr)

                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }
                let start_name = k
                while k < elen and is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                let name = str_slice(expr, start_name, k)
                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }

                let did_call = 0

                // func call: {name(16)} or {name(x)}
                if k < elen and str_char(expr, k) == 40 {
                    let did_call = 1
                    let k = k + 1
                    while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }

                    let arg_val = 0
                    let parsed_num = 0

                    if k < elen and is_digit_char(str_char(expr, k)) != 0 {
                        let start = k
                        while k < elen and is_digit_char(str_char(expr, k)) != 0 { let k = k + 1 }
                        let arg_val = parse_int(str_slice(expr, start, k))
                        let parsed_num = 1
                    }

                    if parsed_num == 0 {
                        let start = k
                        while k < elen and is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                        let arg_name = str_slice(expr, start, k)
                        let arg_val = env_find(vals_env, arg_name)
                    }

                    let args = list_create()
                    list_push(args, arg_val)
                    let v = ceval_call_value(name, args, envs)
                    print(v)
                }

                // variable: {x}
                if did_call == 0 {
                    let def = env_find(defs_env, name)
                    if def != 0 {
                        let v = env_find(vals_env, name)
                        print(v)
                    }
                    if def == 0 {
                        print_char(123)
                        print_bytes(name)
                        print_char(125)
                    }
                }

                let i = j + 1
            }

            if j >= n {
                print_char(123)
                let i = i + 1
            }
        }

        if c != 123 {
            let handled = 0
            if c == 92 and (i + 1) < n and str_char(raw, i + 1) == 110 {
                print_char(10)
                let i = i + 2
                let handled = 1
            }
            if handled == 0 {
                print_char(c)
                let i = i + 1
            }
        }
    }
    return 0
}

fn ceval_stmt(stmt, envs) {
    let tag = list_get(stmt, 0)

    if tag == 102 { return ceval_block(stmt, envs) }

    if tag == 200 {
        let name = list_get(stmt, 1)
        let v = ceval_expr(list_get(stmt, 2), envs)
        if str_len(name) != 0 {
            env_set(ceval_env_vals(envs), name, v)
            env_set(ceval_env_defs(envs), name, 1)
        }
        return ceval_ret_pair(0, 0)
    }

    if tag == 206 {
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        let rhs = ceval_expr(list_get(stmt, 3), envs)
        let out = rhs
        if op == 30 { let out = env_find(ceval_env_vals(envs), name) + out }
        if str_len(name) != 0 {
            env_set(ceval_env_vals(envs), name, out)
            env_set(ceval_env_defs(envs), name, 1)
        }
        return ceval_ret_pair(0, 0)
    }

    if tag == 201 {
        let expr = list_get(stmt, 1)
        if list_get(expr, 0) == 301 { ceval_render_string(list_get(expr, 1), envs) }
        if list_get(expr, 0) != 301 { print(ceval_expr(expr, envs)) }
        return ceval_ret_pair(0, 0)
    }

    if tag == 202 {
        let expr = list_get(stmt, 1)
        if expr == 0 { return ceval_ret_pair(1, 0) }
        return ceval_ret_pair(1, ceval_expr(expr, envs))
    }

    if tag == 203 {
        if ceval_expr(list_get(stmt, 1), envs) != 0 {
            return ceval_block(list_get(stmt, 2), envs)
        }
        let else_block = list_get(stmt, 3)
        if else_block != 0 {
            return ceval_block(else_block, envs)
        }
        return ceval_ret_pair(0, 0)
    }

    if tag == 204 {
        let cond_expr = list_get(stmt, 1)
        let body = list_get(stmt, 2)
        while ceval_expr(cond_expr, envs) != 0 {
            let r = ceval_block(body, envs)
            if ceval_ret_did(r) != 0 { return r }
        }
        return ceval_ret_pair(0, 0)
    }

    if tag == 207 {
        let name = list_get(stmt, 1)
        let start = ceval_expr(list_get(stmt, 2), envs)
        let end = ceval_expr(list_get(stmt, 3), envs)
        let body = list_get(stmt, 4)
        while start < end {
            if str_len(name) != 0 {
                env_set(ceval_env_vals(envs), name, start)
                env_set(ceval_env_defs(envs), name, 1)
            }
            let r = ceval_block(body, envs)
            if ceval_ret_did(r) != 0 { return r }
            let start = start + 1
        }
        return ceval_ret_pair(0, 0)
    }

    if tag == 205 {
        ceval_expr(list_get(stmt, 1), envs)
        return ceval_ret_pair(0, 0)
    }

    return ceval_ret_pair(0, 0)
}

fn ceval_block(block, envs) {
    let stmts = list_get(block, 1)
    let i = 0
    let n = list_len(stmts)
    while i < n {
        let r = ceval_stmt(list_get(stmts, i), envs)
        if ceval_ret_did(r) != 0 { return r }
        let i = i + 1
    }
    return ceval_ret_pair(0, 0)
}

fn ceval_program(prog, prog_args) {
    let funcs = list_get(prog, 1)

    let ceval_funcs = env_create(0)
    let i = 0
    let n = list_len(funcs)
    while i < n {
        let f = list_get(funcs, i)
        env_set(ceval_funcs, list_get(f, 1), f)
        let i = i + 1
    }

    let ceval_args = prog_args

    let vals = env_create(0)
    let defs = env_create(0)
    let envs = pair(vals, defs)
    let args = list_create()
    ceval_call_value("main", args, envs)
    return 0
}

fn main() {
    let do_parse = 0
    let do_eval = 0
    let dump_tree = 0
    let path = "src/vex.vex"
    if 1 < arg_len() {
        let first = arg_get(1)

        if str_eq(first, "parse") {
            let do_parse = 1
            if 2 < arg_len() { let path = arg_get(2) }
            if 3 < arg_len() {
                if str_eq(arg_get(3), "dump") { let dump_tree = 1 }
            }
        }

        if str_eq(first, "eval") {
            let do_eval = 1
            if 2 < arg_len() { let path = arg_get(2) }
        }

        if do_parse == 0 and do_eval == 0 and str_eq(first, "lex") {
            if 2 < arg_len() { let path = arg_get(2) }
        }

        if do_parse == 0 and do_eval == 0 and str_eq(first, "lex") == 0 and str_eq(first, "parse") == 0 and str_eq(first, "eval") == 0 {
            let path = first
        }
    }

    let src = read_file(path)
    let toks = tokenize(src)

    if do_parse == 1 {
        let prog = parse_program(toks)
        if dump_tree == 1 { dump_program_tree(prog) }
        if dump_tree == 0 { dump_program_summary(prog) }
        return
    }

    if do_eval == 1 {
        let prog = parse_program(toks)
        let prog_args = list_create()
        list_push(prog_args, path)
        let i = 3
        while i < arg_len() {
            list_push(prog_args, arg_get(i))
            let i = i + 1
        }
        ceval_program(prog, prog_args)
        return
    }

    let total = list_len(toks) / 2
    print("tokenized {path}\n")
    print("tokens: {total}\n")
    dump_tokens(toks, 20)
}
