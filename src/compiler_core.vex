// src/compiler_core.vex
// Core compiler written in Vex (tokenize/parse/eval/bc).

use "./core/lex.vex"

let parse_path = ""
let parse_src = ""
let parse_error_count = 0

fn pair(a, b) {
    let p = list_create()
    list_push(p, a)
    list_push(p, b)
    return p
}

fn pair_node(p) { return list_get(p, 0) }
fn pair_pos(p) { return list_get(p, 1) }

fn tok_kind(toks, pos) {
    let idx = pos * 4
    if idx < list_len(toks) { return list_get(toks, idx) }
    return 0
}

fn tok_text(toks, pos) {
    let idx = pos * 4 + 1
    if idx < list_len(toks) { return list_get(toks, idx) }
    return ""
}

fn tok_line(toks, pos) {
    let idx = pos * 4 + 2
    if idx < list_len(toks) { return list_get(toks, idx) }
    return 1
}

fn tok_col(toks, pos) {
    let idx = pos * 4 + 3
    if idx < list_len(toks) { return list_get(toks, idx) }
    return 1
}

fn parse_int(s) {
    let v = 0
    let i = 0
    let n = str_len(s)
    while i < n {
        let c = str_char(s, i)
        if c < 48 { return v }
        if 57 < c { return v }
        let v = v * 10 + (c - 48)
        let i = i + 1
    }
    return v
}

fn strip_quotes(s) {
    let n = str_len(s)
    if n < 2 { return s }
    if str_char(s, 0) == 34 and str_char(s, n - 1) == 34 {
        return str_slice(s, 1, n - 1)
    }
    return s
}

fn path_dirname(path) {
    let n = str_len(path)
    let i = n - 1
    while i >= 0 {
        let c = str_char(path, i)
        if c == 47 or c == 92 { return str_slice(path, 0, i) }
        let i = i - 1
    }
    return ""
}

fn line_slice(src, target_line) {
    let n = str_len(src)
    let i = 0
    let line = 1
    let start = 0
    while i < n {
        let c = str_char(src, i)
        if c == 10 {
            if line == target_line { return str_slice(src, start, i) }
            let line = line + 1
            let i = i + 1
            let start = i
            continue
        }
        let i = i + 1
    }
    if line == target_line { return str_slice(src, start, n) }
    return ""
}

fn print_caret(col) {
    let i = 1
    while i < col {
        print(" ")
        let i = i + 1
    }
    print("^\n")
    return 0
}

fn parse_error_at(toks, pos, msg) {
    let line = tok_line(toks, pos)
    let col = tok_col(toks, pos)
    if str_len(parse_path) != 0 {
        print("[vex] error: {parse_path}:{line}:{col}: {msg}\n")
    } else {
        print("[vex] error: {line}:{col}: {msg}\n")
    }
    let src_text = parse_src
    if str_len(src_text) != 0 {
        let line_text = line_slice(src_text, line)
        if str_len(line_text) != 0 {
            print(line_text)
            print("\n")
            let caret_col = col
            if caret_col < 1 { let caret_col = 1 }
            print_caret(caret_col)
        }
    }
    let parse_error_count = parse_error_count + 1
    return 0
}

// --- AST tags ---
// Program: [100, funcs]
// Func:    [101, name, p1, p2, p3, is_accel, body_block, params]
// Block:   [102, stmts]
// Stmts:   let [200, name, expr]
//          print [201, expr]
//          return [202, expr_or_0]
//          if [203, cond, then_block, else_block_or_0]
//          while [204, cond, body_block]
//          assign [206, op_kind, name, expr] // op_kind: Equal or PlusEq
//          for [207, name, start_expr, end_expr, body_block]
//          index_assign [208, op_kind, name, index_expr, value_expr] // op_kind: Equal or PlusEq
//          break [209]
//          continue [210]
//          expr [205, expr]
// Exprs:   int [300, value]
//          str [301, value]
//          name [302, ident]
//          bin [303, op_kind, left, right]
//          call [304, callee, args]

fn make_block(stmts) {
    let b = list_create()
    list_push(b, 102)
    list_push(b, stmts)
    return b
}

fn make_noop_stmt() {
    let expr = list_create()
    list_push(expr, 300)
    list_push(expr, 0)
    let node = list_create()
    list_push(node, 205)
    list_push(node, expr)
    return node
}

fn parse_primary(toks, pos) {
    let k = tok_kind(toks, pos)

    if k == 31 {
        let node = list_create()
        list_push(node, 300)
        list_push(node, 1)
        return pair(node, pos + 1)
    }
    if k == 32 {
        let node = list_create()
        list_push(node, 300)
        list_push(node, 0)
        return pair(node, pos + 1)
    }
    if k == 33 {
        let node = list_create()
        list_push(node, 300)
        list_push(node, 0)
        return pair(node, pos + 1)
    }

    if k == 2 {
        let txt = tok_text(toks, pos)
        let node = list_create()
        list_push(node, 300)
        list_push(node, parse_int(txt))
        return pair(node, pos + 1)
    }

    if k == 3 {
        let raw = tok_text(toks, pos)
        let node = list_create()
        list_push(node, 301)
        list_push(node, strip_quotes(raw))
        return pair(node, pos + 1)
    }

    if k == 29 {
        if tok_kind(toks, pos + 1) == 1 {
            let node = list_create()
            list_push(node, 301)
            list_push(node, tok_text(toks, pos + 1))
            return pair(node, pos + 2)
        }
        parse_error_at(toks, pos, "dot literal expects identifier")
        let node = list_create()
        list_push(node, 301)
        list_push(node, "")
        return pair(node, pos + 1)
    }

    if k == 1 {
        let name = tok_text(toks, pos)
        if tok_kind(toks, pos + 1) == 11 {
            let pos = pos + 2
            let args = list_create()
            while tok_kind(toks, pos) != 12 and tok_kind(toks, pos) != 0 {
                let r = parse_expr(toks, pos)
                list_push(args, pair_node(r))
                let pos = pair_pos(r)
            }
            if tok_kind(toks, pos) == 12 { let pos = pos + 1 }

            let node = list_create()
            list_push(node, 304)
            list_push(node, name)
            list_push(node, args)
            return pair(node, pos)
        }

        let node = list_create()
        list_push(node, 302)
        list_push(node, name)
        return pair(node, pos + 1)
    }

    if k == 11 {
        let r = parse_expr(toks, pos + 1)
        let expr = pair_node(r)
        let pos = pair_pos(r)
        let close_k = tok_kind(toks, pos)
        if close_k == 12 { let pos = pos + 1 }
        if close_k != 12 { parse_error_at(toks, pos, "expected ')'") }
        return pair(expr, pos)
    }

    let node = list_create()
    list_push(node, 302)
    list_push(node, "")
    return pair(node, pos + 1)
}

fn parse_postfix(toks, pos) {
    let r = parse_primary(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let did = 0

        // member access: obj.field -> env_find(obj, "field")
        if tok_kind(toks, pos) == 29 and tok_kind(toks, pos + 1) == 1 {
            let field = tok_text(toks, pos + 1)
            let pos = pos + 2

            let args = list_create()
            list_push(args, lhs)

            let key = list_create()
            list_push(key, 301)
            list_push(key, field)
            list_push(args, key)

            let node = list_create()
            list_push(node, 304)
            list_push(node, "env_find")
            list_push(node, args)
            let lhs = node
            let did = 1
        }

        // indexing: xs[i] -> list_get(xs, i)
        if did == 0 and tok_kind(toks, pos) == 37 {
            let r2 = parse_expr(toks, pos + 1)
            let idx_expr = pair_node(r2)
            let pos = pair_pos(r2)
            let close_k = tok_kind(toks, pos)
            if close_k == 38 { let pos = pos + 1 }
            if close_k != 38 { parse_error_at(toks, pos, "expected ']'") }

            let args = list_create()
            list_push(args, lhs)
            list_push(args, idx_expr)

            let node = list_create()
            list_push(node, 304)
            list_push(node, "list_get")
            list_push(node, args)
            let lhs = node
            let did = 1
        }

        if did == 0 { return pair(lhs, pos) }
    }
    return pair(lhs, pos)
}

fn parse_term(toks, pos) {
    let r = parse_postfix(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        let is_op = 0
        if k == 20 { let is_op = 1 }
        if k == 21 { let is_op = 1 }
        if is_op == 0 { return pair(lhs, pos) }

        let op = k
        let r2 = parse_postfix(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, op)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_add(toks, pos) {
    let r = parse_term(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        let is_op = 0
        if k == 18 { let is_op = 1 }
        if k == 19 { let is_op = 1 }
        if is_op == 0 { return pair(lhs, pos) }

        let op = k
        let r2 = parse_term(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, op)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_compare(toks, pos) {
    let r = parse_add(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        let is_op = 0
        if k == 22 { let is_op = 1 }
        if k == 23 { let is_op = 1 }
        if k == 26 { let is_op = 1 }
        if k == 27 { let is_op = 1 }
        if is_op == 0 { return pair(lhs, pos) }

        let op = k
        let r2 = parse_add(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, op)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_eq(toks, pos) {
    let r = parse_compare(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        let is_op = 0
        if k == 16 { let is_op = 1 }
        if k == 17 { let is_op = 1 }
        if is_op == 0 { return pair(lhs, pos) }

        let op = k
        let r2 = parse_compare(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, op)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_and(toks, pos) {
    let r = parse_eq(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        if k != 24 { return pair(lhs, pos) }

        let r2 = parse_eq(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, k)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_or(toks, pos) {
    let r = parse_and(toks, pos)
    let lhs = pair_node(r)
    let pos = pair_pos(r)

    while 1 {
        let k = tok_kind(toks, pos)
        if k != 25 { return pair(lhs, pos) }

        let r2 = parse_and(toks, pos + 1)
        let rhs = pair_node(r2)
        let pos = pair_pos(r2)

        let node = list_create()
        list_push(node, 303)
        list_push(node, k)
        list_push(node, lhs)
        list_push(node, rhs)
        let lhs = node
    }
    return pair(lhs, pos)
}

fn parse_expr(toks, pos) {
    return parse_or(toks, pos)
}

fn parse_block(toks, pos) {
    let stmts = list_create()
    let opened = 0
    if tok_kind(toks, pos) == 13 {
        let opened = 1
        let pos = pos + 1
    }

    while tok_kind(toks, pos) != 14 and tok_kind(toks, pos) != 0 {
        let r = parse_stmt(toks, pos)
        list_push(stmts, pair_node(r))
        let pos = pair_pos(r)
    }

    let has_close = 0
    if tok_kind(toks, pos) == 14 {
        let has_close = 1
        let pos = pos + 1
    }
    if opened != 0 and has_close == 0 { parse_error_at(toks, pos, "expected '}'") }
    return pair(make_block(stmts), pos)
}

fn parse_stmt(toks, pos) {
    let k = tok_kind(toks, pos)

    // let name = expr
    if k == 4 {
        let name = ""
        if tok_kind(toks, pos + 1) != 1 {
            parse_error_at(toks, pos + 1, "let expects identifier")
            return pair(make_noop_stmt(), pos + 1)
        }
        if tok_kind(toks, pos + 1) == 1 { let name = tok_text(toks, pos + 1) }

        let pos = pos + 1
        if tok_kind(toks, pos) == 1 { let pos = pos + 1 }
        while tok_kind(toks, pos) != 15 and tok_kind(toks, pos) != 0 { let pos = pos + 1 }
        let saw_equal = 0
        if tok_kind(toks, pos) == 15 {
            let saw_equal = 1
            let pos = pos + 1
        }
        if saw_equal == 0 {
            parse_error_at(toks, pos, "let expects '='")
            return pair(make_noop_stmt(), pos)
        }

        let r = parse_expr(toks, pos)
        let expr = pair_node(r)
        let pos = pair_pos(r)

        let node = list_create()
        list_push(node, 200)
        list_push(node, name)
        list_push(node, expr)
        return pair(node, pos)
    }

    // print(expr)
    if k == 5 {
        let pos = pos + 1
        let had_paren = 0
        if tok_kind(toks, pos) == 11 {
            let had_paren = 1
            let pos = pos + 1
        }

        let r = parse_expr(toks, pos)
        let expr = pair_node(r)
        let pos = pair_pos(r)

        let close_k = tok_kind(toks, pos)
        if close_k == 12 { let pos = pos + 1 }
        if had_paren != 0 and close_k != 12 { parse_error_at(toks, pos, "expected ')' after print expr") }

        let node = list_create()
        list_push(node, 201)
        list_push(node, expr)
        return pair(node, pos)
    }

    // return expr?
    if k == 7 {
        let pos = pos + 1
        let expr = 0
        let next = tok_kind(toks, pos)
        if next != 14 and next != 0 {
            let r = parse_expr(toks, pos)
            let expr = pair_node(r)
            let pos = pair_pos(r)
        }

        let node = list_create()
        list_push(node, 202)
        list_push(node, expr)
        return pair(node, pos)
    }

    // if cond { ... } or if cond stmt
    if k == 8 {
        let pos = pos + 1
        let r = parse_expr(toks, pos)
        let cond = pair_node(r)
        let pos = pair_pos(r)

        let then_block = 0
        let did_then = 0
        if tok_kind(toks, pos) == 13 {
            let br = parse_block(toks, pos)
            let then_block = pair_node(br)
            let pos = pair_pos(br)
            let did_then = 1
        }
        if did_then == 0 {
            let sr = parse_stmt(toks, pos)
            let inner = pair_node(sr)
            let pos = pair_pos(sr)
            let stmts = list_create()
            list_push(stmts, inner)
            let then_block = make_block(stmts)
        }

        let else_block = 0
        if tok_kind(toks, pos) == 28 {
            let pos = pos + 1

            let did_else = 0
            if tok_kind(toks, pos) == 13 {
                let br = parse_block(toks, pos)
                let else_block = pair_node(br)
                let pos = pair_pos(br)
                let did_else = 1
            }
            if did_else == 0 {
                let sr = parse_stmt(toks, pos)
                let inner = pair_node(sr)
                let pos = pair_pos(sr)
                let stmts = list_create()
                list_push(stmts, inner)
                let else_block = make_block(stmts)
            }
        }

        let node = list_create()
        list_push(node, 203)
        list_push(node, cond)
        list_push(node, then_block)
        list_push(node, else_block)
        return pair(node, pos)
    }

    // while cond { ... }
    if k == 9 {
        let pos = pos + 1
        let r = parse_expr(toks, pos)
        let cond = pair_node(r)
        let pos = pair_pos(r)

        let body = 0
        if tok_kind(toks, pos) == 13 {
            let br = parse_block(toks, pos)
            let body = pair_node(br)
            let pos = pair_pos(br)

            let node = list_create()
            list_push(node, 204)
            list_push(node, cond)
            list_push(node, body)
            return pair(node, pos)
        }

        let sr = parse_stmt(toks, pos)
        let inner = pair_node(sr)
        let pos = pair_pos(sr)
        let stmts = list_create()
        list_push(stmts, inner)
        let body = make_block(stmts)

        let node = list_create()
        list_push(node, 204)
        list_push(node, cond)
        list_push(node, body)
        return pair(node, pos)
    }

    // for name in start..end { ... }
    if k == 34 {
        let pos = pos + 1
        let name = ""
        if tok_kind(toks, pos) != 1 {
            parse_error_at(toks, pos, "for expects identifier")
            return pair(make_noop_stmt(), pos)
        }
        if tok_kind(toks, pos) == 1 { let name = tok_text(toks, pos) }

        if tok_kind(toks, pos) == 1 { let pos = pos + 1 }
        if tok_kind(toks, pos) != 35 {
            parse_error_at(toks, pos, "for expects 'in'")
            return pair(make_noop_stmt(), pos)
        }
        if tok_kind(toks, pos) == 35 { let pos = pos + 1 }

        let r1 = parse_expr(toks, pos)
        let start_expr = pair_node(r1)
        let pos = pair_pos(r1)

        if tok_kind(toks, pos) != 36 {
            parse_error_at(toks, pos, "for expects '..'")
            return pair(make_noop_stmt(), pos)
        }
        if tok_kind(toks, pos) == 36 { let pos = pos + 1 }

        let r2 = parse_expr(toks, pos)
        let end_expr = pair_node(r2)
        let pos = pair_pos(r2)

        let body = 0
        if tok_kind(toks, pos) == 13 {
            let br = parse_block(toks, pos)
            let body = pair_node(br)
            let pos = pair_pos(br)
        }
        if body == 0 {
            let sr = parse_stmt(toks, pos)
            let inner = pair_node(sr)
            let pos = pair_pos(sr)
            let stmts = list_create()
            list_push(stmts, inner)
            let body = make_block(stmts)
        }

        let node = list_create()
        list_push(node, 207)
        list_push(node, name)
        list_push(node, start_expr)
        list_push(node, end_expr)
        list_push(node, body)
        return pair(node, pos)
    }

    // break
    if k == 39 {
        let node = list_create()
        list_push(node, 209)
        return pair(node, pos + 1)
    }

    // continue
    if k == 40 {
        let node = list_create()
        list_push(node, 210)
        return pair(node, pos + 1)
    }

    // { ... }
    if k == 13 {
        let br = parse_block(toks, pos)
        let block = pair_node(br)
        let pos = pair_pos(br)
        return pair(block, pos)
    }

    // name[idx] = expr / name[idx] += expr
    if k == 1 and tok_kind(toks, pos + 1) == 37 {
        let name = tok_text(toks, pos)

        let ir = parse_expr(toks, pos + 2)
        let idx_expr = pair_node(ir)
        let pos = pair_pos(ir)
        let close_k = tok_kind(toks, pos)
        if close_k == 38 { let pos = pos + 1 }
        if close_k != 38 { parse_error_at(toks, pos, "expected ']'") }

        let op = tok_kind(toks, pos)
        if op == 15 or op == 30 {
            let vr = parse_expr(toks, pos + 1)
            let val_expr = pair_node(vr)
            let pos = pair_pos(vr)

            let node = list_create()
            list_push(node, 208)
            list_push(node, op)
            list_push(node, name)
            list_push(node, idx_expr)
            list_push(node, val_expr)
            return pair(node, pos)
        }
    }

    // name = expr / name += expr
    if k == 1 {
        let name = tok_text(toks, pos)
        let op = tok_kind(toks, pos + 1)
        if op == 15 or op == 30 {
            let r = parse_expr(toks, pos + 2)
            let expr = pair_node(r)
            let pos = pair_pos(r)

            let node = list_create()
            list_push(node, 206)
            list_push(node, op)
            list_push(node, name)
            list_push(node, expr)
            return pair(node, pos)
        }
    }

    // Fallback: expression statement.
    let r = parse_expr(toks, pos)
    let expr = pair_node(r)
    let pos = pair_pos(r)

    let node = list_create()
    list_push(node, 205)
    list_push(node, expr)
    return pair(node, pos)
}

fn parse_func(toks, pos, is_accel) {
    // consume 'fn'
    if tok_kind(toks, pos) == 6 { let pos = pos + 1 }

    let name = tok_text(toks, pos)
    if tok_kind(toks, pos) != 1 {
        parse_error_at(toks, pos, "fn expects a name")
    }
    if tok_kind(toks, pos) == 1 { let pos = pos + 1 }

    let p1 = ""
    let p2 = ""
    let p3 = ""
    let params = list_create()
    let param_i = 0

    if tok_kind(toks, pos) == 11 {
        let pos = pos + 1
        while tok_kind(toks, pos) != 12 and tok_kind(toks, pos) != 0 {
            if tok_kind(toks, pos) == 1 {
                if param_i == 0 { let p1 = tok_text(toks, pos) }
                if param_i == 1 { let p2 = tok_text(toks, pos) }
                if param_i == 2 { let p3 = tok_text(toks, pos) }
                list_push(params, tok_text(toks, pos))
                let param_i = param_i + 1
            }
            let pos = pos + 1
        }
        let close_k = tok_kind(toks, pos)
        if close_k == 12 { let pos = pos + 1 }
        if close_k != 12 { parse_error_at(toks, pos, "expected ')' after params") }
    }

    while tok_kind(toks, pos) != 13 and tok_kind(toks, pos) != 0 { let pos = pos + 1 }
    let body = 0
    if tok_kind(toks, pos) == 13 {
        let br = parse_block(toks, pos)
        let body = pair_node(br)
        let pos = pair_pos(br)
    }
    if body == 0 {
        parse_error_at(toks, pos, "expected '{' to start function body")
        let body = make_block(list_create())
    }

    let node = list_create()
    list_push(node, 101)
    list_push(node, name)
    list_push(node, p1)
    list_push(node, p2)
    list_push(node, p3)
    list_push(node, is_accel)
    list_push(node, body)
    list_push(node, params)
    return pair(node, pos)
}

fn list_extend(dst, src) {
    let i = 0
    let n = list_len(src)
    while i < n {
        list_push(dst, list_get(src, i))
        let i = i + 1
    }
    return 0
}

fn parse_program(toks, path, src, imports_seen) {
    let parse_path = path
    let parse_src = src
    let funcs = list_create()
    let pos = 0

    while tok_kind(toks, pos) != 0 {
        // use "./file.vex" (top-level include; merges functions into this program)
        if tok_kind(toks, pos) == 41 {
            let pos = pos + 1
            if tok_kind(toks, pos) != 3 {
                parse_error_at(toks, pos, "use expects a string path")
                continue
            }

            let raw_path = strip_quotes(tok_text(toks, pos))
            let pos = pos + 1

            let full_path = raw_path
            let base_dir = path_dirname(path)
            if str_len(base_dir) != 0 {
                let full_path = path_join(base_dir, raw_path)
            }

            if env_find(imports_seen, full_path) == 0 {
                env_set(imports_seen, full_path, 1)
                let src2 = read_file(full_path)
                let toks2 = tokenize_with_pos(src2)
                let prog2 = parse_program(toks2, full_path, src2, imports_seen)
                list_extend(funcs, list_get(prog2, 1))
            }
            continue
        }

        let is_accel = 0
        if tok_kind(toks, pos) == 10 {
            let is_accel = 1
            let pos = pos + 1
        }

        if tok_kind(toks, pos) == 6 {
            let fr = parse_func(toks, pos, is_accel)
            list_push(funcs, pair_node(fr))
            let pos = pair_pos(fr)
        }

        if tok_kind(toks, pos) != 6 {
            let pos = pos + 1
        }
    }

    let prog = list_create()
    list_push(prog, 100)
    list_push(prog, funcs)
    return prog
}

// --- Eval (Vex-in-Vex execution) ---

fn ret_pair(kind, value) {
    let r = list_create()
    list_push(r, kind)
    list_push(r, value)
    return r
}

fn ret_kind(r) { return list_get(r, 0) }
fn ret_val(r) { return list_get(r, 1) }

fn is_digit_char(c) {
    if 47 < c and c < 58 { return 1 }
    return 0
}

fn is_ident_char(c) {
    if c == 95 { return 1 }
    if 47 < c and c < 58 { return 1 }
    if 64 < c and c < 91 { return 1 }
    if 96 < c and c < 123 { return 1 }
    return 0
}

fn eval_expr(expr, func_env, vals_env, defs_env, prog_args) {
    let tag = list_get(expr, 0)

    if tag == 300 { return list_get(expr, 1) }
    if tag == 301 { return list_get(expr, 1) }
    if tag == 302 {
        let name = list_get(expr, 1)
        return env_find(vals_env, name)
    }

    if tag == 303 {
        let op = list_get(expr, 1)
        let lhs = eval_expr(list_get(expr, 2), func_env, vals_env, defs_env, prog_args)
        let rhs = eval_expr(list_get(expr, 3), func_env, vals_env, defs_env, prog_args)

        if op == 18 { return lhs + rhs }
        if op == 19 { return lhs - rhs }
        if op == 20 { return lhs * rhs }
        if op == 21 { return lhs / rhs }

        if op == 22 {
            let out = 0
            if lhs < rhs { let out = 1 }
            return out
        }
        if op == 23 {
            let out = 0
            if lhs <= rhs { let out = 1 }
            return out
        }
        if op == 26 {
            let out = 0
            if lhs > rhs { let out = 1 }
            return out
        }
        if op == 27 {
            let out = 0
            if lhs >= rhs { let out = 1 }
            return out
        }
        if op == 16 {
            let out = 0
            if lhs == rhs { let out = 1 }
            return out
        }
        if op == 17 {
            let out = 0
            if lhs != rhs { let out = 1 }
            return out
        }
        if op == 24 {
            let out = 0
            if lhs != 0 and rhs != 0 { let out = 1 }
            return out
        }
        if op == 25 {
            let out = 0
            if lhs != 0 or rhs != 0 { let out = 1 }
            return out
        }

        return 0
    }

    if tag == 304 {
        let name = list_get(expr, 1)
        let args = list_get(expr, 2)
        return eval_call_expr(name, args, func_env, vals_env, defs_env, prog_args)
    }

    return 0
}

fn eval_arg_expr(args, idx, func_env, vals_env, defs_env, prog_args) {
    let e = list_get(args, idx)
    if e == 0 { return 0 }
    return eval_expr(e, func_env, vals_env, defs_env, prog_args)
}

fn eval_user_func(func_node, a0, a1, a2, func_env, caller_vals, caller_defs, prog_args) {
    let p1 = list_get(func_node, 2)
    let p2 = list_get(func_node, 3)
    let p3 = list_get(func_node, 4)
    let body = list_get(func_node, 6)

    let vals = env_create(caller_vals)
    let defs = env_create(caller_defs)

    if str_len(p1) != 0 {
        env_set(vals, p1, a0)
        env_set(defs, p1, 1)
    }
    if str_len(p2) != 0 {
        env_set(vals, p2, a1)
        env_set(defs, p2, 1)
    }
    if str_len(p3) != 0 {
        env_set(vals, p3, a2)
        env_set(defs, p3, 1)
    }

    let r = eval_block(body, func_env, vals, defs, prog_args)
    let k = ret_kind(r)
    if k == 1 { return ret_val(r) }
    if k != 0 { print("[control flow escaped function]\n") }
    return 0
}

fn call3(name, a0, a1, a2, argc, func_env, vals_env, defs_env, prog_args) {
    if str_eq(name, "env_create") { return env_create(a0) }
    if str_eq(name, "env_set") {
        env_set(a0, a1, a2)
        return 0
    }
    if str_eq(name, "env_find") { return env_find(a0, a1) }
    if str_eq(name, "env_destroy") {
        env_destroy(a0)
        return 0
    }

    if str_eq(name, "str_len") { return str_len(a0) }
    if str_eq(name, "str_char") { return str_char(a0, a1) }
    if str_eq(name, "str_slice") { return str_slice(a0, a1, a2) }
    if str_eq(name, "consume_digits") { return consume_digits(a0, a1) }
    if str_eq(name, "consume_ident") { return consume_ident(a0, a1) }
    if str_eq(name, "skip_line_comment") { return skip_line_comment(a0, a1) }
    if str_eq(name, "vexc_consume_digits") { return vexc_consume_digits(a0, a1, a2) }
    if str_eq(name, "vexc_consume_ident") { return vexc_consume_ident(a0, a1, a2) }
    if str_eq(name, "vexc_tokenize_native") { return vexc_tokenize_native(a0) }

    if str_eq(name, "print_bytes") {
        print_bytes(a0)
        return 0
    }
    if str_eq(name, "print_char") {
        print_char(a0)
        return 0
    }

    if str_eq(name, "list_create") { return list_create() }
    if str_eq(name, "list_push") {
        list_push(a0, a1)
        return 0
    }
    if str_eq(name, "list_len") { return list_len(a0) }
    if str_eq(name, "list_get") { return list_get(a0, a1) }
    if str_eq(name, "list_set") {
        list_set(a0, a1, a2)
        return 0
    }
    if str_eq(name, "list_destroy") {
        list_destroy(a0)
        return 0
    }

    if str_eq(name, "read_file") { return read_file(a0) }
    if str_eq(name, "write_file") {
        write_file(a0, a1)
        return 0
    }
    if str_eq(name, "path_join") { return path_join(a0, a1) }

    if str_eq(name, "arg_len") { return list_len(prog_args) }
    if str_eq(name, "arg_get") {
        let idx = a0
        let n = list_len(prog_args)
        if idx < 0 { return "" }
        if idx < n { return list_get(prog_args, idx) }
        return ""
    }

    let func_node = env_find(func_env, name)
    if func_node == 0 {
        print("[undefined function] {name}\n")
        return 0
    }

    return eval_user_func(func_node, a0, a1, a2, func_env, vals_env, defs_env, prog_args)
}

fn eval_call_expr(name, args, func_env, vals_env, defs_env, prog_args) {
    let argc = list_len(args)
    let argc_use = argc
    if 3 < argc_use { let argc_use = 3 }

    let a0 = 0
    let a1 = 0
    let a2 = 0
    if 0 < argc_use { let a0 = eval_arg_expr(args, 0, func_env, vals_env, defs_env, prog_args) }
    if 1 < argc_use { let a1 = eval_arg_expr(args, 1, func_env, vals_env, defs_env, prog_args) }
    if 2 < argc_use { let a2 = eval_arg_expr(args, 2, func_env, vals_env, defs_env, prog_args) }

    return call3(name, a0, a1, a2, argc_use, func_env, vals_env, defs_env, prog_args)
}

fn render_string(func_env, vals_env, defs_env, prog_args, raw) {
    let i = 0
    let n = str_len(raw)
    while i < n {
        let c = str_char(raw, i)

        if c == 123 {
            let j = i + 1
            while j < n and str_char(raw, j) != 125 { let j = j + 1 }

            if j < n {
                let expr = str_slice(raw, i + 1, j)
                let k = 0
                let elen = str_len(expr)

                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }
                let start_name = k
                while k < elen and is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                let name = str_slice(expr, start_name, k)
                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }

                let did_call = 0

                // func call: {name(16)} or {name(x)}
                if k < elen and str_char(expr, k) == 40 {
                    let did_call = 1
                    let k = k + 1
                    while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }

                    let arg_val = 0
                    let parsed_num = 0

                    if k < elen and is_digit_char(str_char(expr, k)) != 0 {
                        let start = k
                        while k < elen and is_digit_char(str_char(expr, k)) != 0 { let k = k + 1 }
                        let arg_val = parse_int(str_slice(expr, start, k))
                        let parsed_num = 1
                    }

                    if parsed_num == 0 {
                        let start = k
                        while k < elen and is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                        let arg_name = str_slice(expr, start, k)
                        let arg_val = env_find(vals_env, arg_name)
                    }

                    let v = call3(name, arg_val, 0, 0, 1, func_env, vals_env, defs_env, prog_args)
                    print(v)
                }

                // variable: {x}
                if did_call == 0 {
                    let def = env_find(defs_env, name)
                    if def != 0 {
                        let v = env_find(vals_env, name)
                        print(v)
                    }
                    if def == 0 {
                        print_char(123)
                        print_bytes(name)
                        print_char(125)
                    }
                }

                let i = j + 1
            }

            if j >= n {
                print_char(123)
                let i = i + 1
            }
        }

        if c != 123 {
            let handled = 0
            if c == 92 and (i + 1) < n and str_char(raw, i + 1) == 110 {
                print_char(10)
                let i = i + 2
                let handled = 1
            }
            if handled == 0 {
                print_char(c)
                let i = i + 1
            }
        }
    }
    return 0
}

fn eval_stmt(stmt, func_env, vals_env, defs_env, prog_args) {
    let tag = list_get(stmt, 0)

    if tag == 102 { return eval_block(stmt, func_env, vals_env, defs_env, prog_args) }

    if tag == 200 {
        let name = list_get(stmt, 1)
        let expr = list_get(stmt, 2)
        let v = eval_expr(expr, func_env, vals_env, defs_env, prog_args)
        if str_len(name) != 0 {
            env_set(vals_env, name, v)
            env_set(defs_env, name, 1)
        }
        return ret_pair(0, 0)
    }

    if tag == 206 {
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        let expr = list_get(stmt, 3)
        let rhs = eval_expr(expr, func_env, vals_env, defs_env, prog_args)
        let out = rhs
        if op == 30 { let out = env_find(vals_env, name) + out }
        if str_len(name) != 0 {
            env_set(vals_env, name, out)
            env_set(defs_env, name, 1)
        }
        return ret_pair(0, 0)
    }

    if tag == 208 {
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        let idx = eval_expr(list_get(stmt, 3), func_env, vals_env, defs_env, prog_args)
        let rhs = eval_expr(list_get(stmt, 4), func_env, vals_env, defs_env, prog_args)
        let list_handle = env_find(vals_env, name)
        let out = rhs
        if op == 30 { let out = call3("list_get", list_handle, idx, 0, 2, func_env, vals_env, defs_env, prog_args) + out }
        call3("list_set", list_handle, idx, out, 3, func_env, vals_env, defs_env, prog_args)
        return ret_pair(0, 0)
    }

    if tag == 201 {
        let expr = list_get(stmt, 1)
        if list_get(expr, 0) == 301 {
            render_string(func_env, vals_env, defs_env, prog_args, list_get(expr, 1))
        }
        if list_get(expr, 0) != 301 {
            let v = eval_expr(expr, func_env, vals_env, defs_env, prog_args)
            print(v)
        }
        return ret_pair(0, 0)
    }

    if tag == 202 {
        let expr = list_get(stmt, 1)
        if expr == 0 { return ret_pair(1, 0) }
        let v = eval_expr(expr, func_env, vals_env, defs_env, prog_args)
        return ret_pair(1, v)
    }

    if tag == 209 { return ret_pair(2, 0) }
    if tag == 210 { return ret_pair(3, 0) }

    if tag == 203 {
        let cond = eval_expr(list_get(stmt, 1), func_env, vals_env, defs_env, prog_args)
        if cond != 0 {
            return eval_block(list_get(stmt, 2), func_env, vals_env, defs_env, prog_args)
        }
        let else_block = list_get(stmt, 3)
        if else_block != 0 {
            return eval_block(else_block, func_env, vals_env, defs_env, prog_args)
        }
        return ret_pair(0, 0)
    }

    if tag == 204 {
        let cond_expr = list_get(stmt, 1)
        let body = list_get(stmt, 2)
        while eval_expr(cond_expr, func_env, vals_env, defs_env, prog_args) != 0 {
            let r = eval_block(body, func_env, vals_env, defs_env, prog_args)
            let k = ret_kind(r)
            if k == 1 { return r }
            if k == 2 { return ret_pair(0, 0) }
        }
        return ret_pair(0, 0)
    }

    if tag == 207 {
        let name = list_get(stmt, 1)
        let start = eval_expr(list_get(stmt, 2), func_env, vals_env, defs_env, prog_args)
        let end = eval_expr(list_get(stmt, 3), func_env, vals_env, defs_env, prog_args)
        let body = list_get(stmt, 4)
        while start < end {
            if str_len(name) != 0 {
                env_set(vals_env, name, start)
                env_set(defs_env, name, 1)
            }
            let r = eval_block(body, func_env, vals_env, defs_env, prog_args)
            let k = ret_kind(r)
            if k == 1 { return r }
            if k == 2 { return ret_pair(0, 0) }
            let start = start + 1
        }
        return ret_pair(0, 0)
    }

    if tag == 205 {
        eval_expr(list_get(stmt, 1), func_env, vals_env, defs_env, prog_args)
        return ret_pair(0, 0)
    }

    return ret_pair(0, 0)
}

fn eval_block(block, func_env, vals_env, defs_env, prog_args) {
    let stmts = list_get(block, 1)
    let i = 0
    let n = list_len(stmts)
    while i < n {
        let s = list_get(stmts, i)
        let r = eval_stmt(s, func_env, vals_env, defs_env, prog_args)
        if ret_kind(r) != 0 { return r }
        let i = i + 1
    }
    return ret_pair(0, 0)
}

fn eval_program(prog, prog_args) {
    let funcs = list_get(prog, 1)
    let func_env = env_create(0)

    let i = 0
    let n = list_len(funcs)
    while i < n {
        let f = list_get(funcs, i)
        env_set(func_env, list_get(f, 1), f)
        let i = i + 1
    }

    let vals = env_create(0)
    let defs = env_create(0)

    call3("main", 0, 0, 0, 0, func_env, vals, defs, prog_args)
    return 0
}

fn indent(depth) {
    let i = 0
    while i < depth {
        print_bytes("  ")
        let i = i + 1
    }
}

fn dump_expr(expr, depth, max_depth) {
    if depth > max_depth { return 0 }

    let tag = list_get(expr, 0)

    if tag == 300 {
        indent(depth)
        let v = list_get(expr, 1)
        print("Int {v}\n")
        return 0
    }
    if tag == 301 {
        indent(depth)
        let s = list_get(expr, 1)
        print("Str \"{s}\"\n")
        return 0
    }
    if tag == 302 {
        indent(depth)
        let name = list_get(expr, 1)
        print("Name {name}\n")
        return 0
    }
    if tag == 304 {
        indent(depth)
        let callee = list_get(expr, 1)
        let args = list_get(expr, 2)
        let argc = list_len(args)
        print("Call {callee} argc={argc}\n")
        let i = 0
        while i < argc {
            dump_expr(list_get(args, i), depth + 1, max_depth)
            let i = i + 1
        }
        return 0
    }
    if tag == 303 {
        indent(depth)
        let op = list_get(expr, 1)
        print("Bin {kind_name(op)}\n")
        dump_expr(list_get(expr, 2), depth + 1, max_depth)
        dump_expr(list_get(expr, 3), depth + 1, max_depth)
        return 0
    }

    indent(depth)
    print("Expr?\n")
    return 0
}

fn dump_stmt(stmt, depth, max_depth) {
    if depth > max_depth { return 0 }

    let tag = list_get(stmt, 0)

    if tag == 200 {
        indent(depth)
        let name = list_get(stmt, 1)
        print("Let {name}\n")
        dump_expr(list_get(stmt, 2), depth + 1, max_depth)
        return 0
    }
    if tag == 206 {
        indent(depth)
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        if op == 30 { print("AddAssign {name}\n") }
        if op != 30 { print("Assign {name}\n") }
        dump_expr(list_get(stmt, 3), depth + 1, max_depth)
        return 0
    }
    if tag == 208 {
        indent(depth)
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        if op == 30 { print("IndexAddAssign {name}\n") }
        if op != 30 { print("IndexAssign {name}\n") }
        dump_expr(list_get(stmt, 3), depth + 1, max_depth)
        dump_expr(list_get(stmt, 4), depth + 1, max_depth)
        return 0
    }
    if tag == 201 {
        indent(depth)
        print("Print\n")
        dump_expr(list_get(stmt, 1), depth + 1, max_depth)
        return 0
    }
    if tag == 202 {
        indent(depth)
        print("Return\n")
        let e = list_get(stmt, 1)
        if e != 0 { dump_expr(e, depth + 1, max_depth) }
        return 0
    }
    if tag == 203 {
        indent(depth)
        print("If\n")
        dump_expr(list_get(stmt, 1), depth + 1, max_depth)
        dump_block(list_get(stmt, 2), depth + 1, max_depth)
        let else_block = list_get(stmt, 3)
        if else_block != 0 {
            indent(depth)
            print("Else\n")
            dump_block(else_block, depth + 1, max_depth)
        }
        return 0
    }
    if tag == 204 {
        indent(depth)
        print("While\n")
        dump_expr(list_get(stmt, 1), depth + 1, max_depth)
        dump_block(list_get(stmt, 2), depth + 1, max_depth)
        return 0
    }
    if tag == 207 {
        indent(depth)
        let name = list_get(stmt, 1)
        print("For {name}\n")
        dump_expr(list_get(stmt, 2), depth + 1, max_depth)
        dump_expr(list_get(stmt, 3), depth + 1, max_depth)
        dump_block(list_get(stmt, 4), depth + 1, max_depth)
        return 0
    }
    if tag == 209 {
        indent(depth)
        print("Break\n")
        return 0
    }
    if tag == 210 {
        indent(depth)
        print("Continue\n")
        return 0
    }
    if tag == 205 {
        indent(depth)
        print("ExprStmt\n")
        dump_expr(list_get(stmt, 1), depth + 1, max_depth)
        return 0
    }
    if tag == 102 {
        dump_block(stmt, depth, max_depth)
        return 0
    }

    indent(depth)
    print("Stmt?\n")
    return 0
}

fn dump_block(block, depth, max_depth) {
    if depth > max_depth { return 0 }

    indent(depth)
    print("Block\n")

    let stmts = list_get(block, 1)
    let n = list_len(stmts)
    let i = 0
    while i < n {
        dump_stmt(list_get(stmts, i), depth + 1, max_depth)
        let i = i + 1
    }
    return 0
}

fn dump_program_summary(prog) {
    let funcs = list_get(prog, 1)
    let n = list_len(funcs)
    print("functions: {n}\n")

    let i = 0
    while i < n {
        let f = list_get(funcs, i)
        let name = list_get(f, 1)
        let is_accel = list_get(f, 5)
        let body = list_get(f, 6)
        let stmts = list_get(body, 1)
        let stmt_count = list_len(stmts)
        print("fn {name} accel={is_accel} stmts={stmt_count}\n")
        let i = i + 1
    }
    return 0
}

fn dump_program_tree(prog) {
    let funcs = list_get(prog, 1)
    let n = list_len(funcs)
    print("Program\n")

    let i = 0
    while i < n {
        let f = list_get(funcs, i)
        let name = list_get(f, 1)
        let is_accel = list_get(f, 5)
        indent(1)
        print("Fn {name} accel={is_accel}\n")
        dump_block(list_get(f, 6), 2, 8)
        let i = i + 1
    }
    return 0
}

// --- Vex-in-Vex execution (Core AST evaluator) ---

fn ceval_ret_pair(kind, value) {
    let r = list_create()
    list_push(r, kind)
    list_push(r, value)
    return r
}

fn ceval_ret_kind(r) { return list_get(r, 0) }
fn ceval_ret_val(r) { return list_get(r, 1) }

fn ceval_env_vals(envs) { return list_get(envs, 0) }
fn ceval_env_defs(envs) { return list_get(envs, 1) }

fn ceval_user_func(func_node, args, caller_envs) {
    let parent_vals = ceval_env_vals(caller_envs)
    let parent_defs = ceval_env_defs(caller_envs)

    let vals = env_create(parent_vals)
    let defs = env_create(parent_defs)

    let params = list_get(func_node, 7)
    if params == 0 {
        let p1 = list_get(func_node, 2)
        let p2 = list_get(func_node, 3)
        let p3 = list_get(func_node, 4)

        let a0 = list_get(args, 0)
        let a1 = list_get(args, 1)
        let a2 = list_get(args, 2)

        if str_len(p1) != 0 {
            env_set(vals, p1, a0)
            env_set(defs, p1, 1)
        }
        if str_len(p2) != 0 {
            env_set(vals, p2, a1)
            env_set(defs, p2, 1)
        }
        if str_len(p3) != 0 {
            env_set(vals, p3, a2)
            env_set(defs, p3, 1)
        }
    }
    if params != 0 {
        let i = 0
        let n = list_len(params)
        while i < n {
            let p = list_get(params, i)
            if str_len(p) != 0 {
                env_set(vals, p, list_get(args, i))
                env_set(defs, p, 1)
            }
            let i = i + 1
        }
    }

    let envs = pair(vals, defs)
    let r = ceval_block(list_get(func_node, 6), envs)
    let k = ceval_ret_kind(r)
    if k == 1 { return ceval_ret_val(r) }
    if k != 0 { print("[control flow escaped function]\n") }
    return 0
}

fn ceval_call_value(name, args, envs) {
    // Builtins
    if str_eq(name, "env_create") { return env_create(list_get(args, 0)) }
    if str_eq(name, "env_set") {
        env_set(list_get(args, 0), list_get(args, 1), list_get(args, 2))
        return 0
    }
    if str_eq(name, "env_find") { return env_find(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "env_destroy") {
        env_destroy(list_get(args, 0))
        return 0
    }

    if str_eq(name, "str_len") { return str_len(list_get(args, 0)) }
    if str_eq(name, "str_char") { return str_char(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "str_slice") { return str_slice(list_get(args, 0), list_get(args, 1), list_get(args, 2)) }
    if str_eq(name, "consume_digits") { return consume_digits(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "consume_ident") { return consume_ident(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "skip_line_comment") { return skip_line_comment(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "vexc_consume_digits") { return vexc_consume_digits(list_get(args, 0), list_get(args, 1), list_get(args, 2)) }
    if str_eq(name, "vexc_consume_ident") { return vexc_consume_ident(list_get(args, 0), list_get(args, 1), list_get(args, 2)) }
    if str_eq(name, "vexc_tokenize_native") { return vexc_tokenize_native(list_get(args, 0)) }
    if str_eq(name, "consume_digits") { return consume_digits(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "consume_ident") { return consume_ident(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "skip_line_comment") { return skip_line_comment(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "vexc_consume_digits") { return vexc_consume_digits(list_get(args, 0), list_get(args, 1), list_get(args, 2)) }
    if str_eq(name, "vexc_consume_ident") { return vexc_consume_ident(list_get(args, 0), list_get(args, 1), list_get(args, 2)) }
    if str_eq(name, "vexc_tokenize_native") { return vexc_tokenize_native(list_get(args, 0)) }

    if str_eq(name, "print_bytes") {
        print_bytes(list_get(args, 0))
        return 0
    }
    if str_eq(name, "print_char") {
        print_char(list_get(args, 0))
        return 0
    }

    if str_eq(name, "list_create") { return list_create() }
    if str_eq(name, "list_push") {
        list_push(list_get(args, 0), list_get(args, 1))
        return 0
    }
    if str_eq(name, "list_len") { return list_len(list_get(args, 0)) }
    if str_eq(name, "list_get") { return list_get(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "list_set") {
        list_set(list_get(args, 0), list_get(args, 1), list_get(args, 2))
        return 0
    }
    if str_eq(name, "list_destroy") {
        list_destroy(list_get(args, 0))
        return 0
    }

    if str_eq(name, "read_file") { return read_file(list_get(args, 0)) }
    if str_eq(name, "write_file") {
        write_file(list_get(args, 0), list_get(args, 1))
        return 0
    }
    if str_eq(name, "path_join") { return path_join(list_get(args, 0), list_get(args, 1)) }

    // Program args (provided by `ceval_program`)
    if str_eq(name, "arg_len") { return list_len(ceval_args) }
    if str_eq(name, "arg_get") {
        let idx = list_get(args, 0)
        let n = list_len(ceval_args)
        if idx < 0 { return "" }
        if idx < n { return list_get(ceval_args, idx) }
        return ""
    }

    // User-defined
    let func_node = env_find(ceval_funcs, name)
    if func_node == 0 {
        print("[undefined function] {name}\n")
        return 0
    }
    return ceval_user_func(func_node, args, envs)
}

fn ceval_call(call_expr, envs) {
    let name = list_get(call_expr, 1)
    let arg_exprs = list_get(call_expr, 2)

    let args = list_create()
    let i = 0
    let n = list_len(arg_exprs)
    while i < n {
        list_push(args, ceval_expr(list_get(arg_exprs, i), envs))
        let i = i + 1
    }
    return ceval_call_value(name, args, envs)
}

fn ceval_expr(expr, envs) {
    let tag = list_get(expr, 0)

    if tag == 300 { return list_get(expr, 1) }
    if tag == 301 { return list_get(expr, 1) }
    if tag == 302 { return env_find(ceval_env_vals(envs), list_get(expr, 1)) }

    if tag == 303 {
        let op = list_get(expr, 1)
        let lhs = ceval_expr(list_get(expr, 2), envs)
        let rhs = ceval_expr(list_get(expr, 3), envs)

        if op == 18 { return lhs + rhs }
        if op == 19 { return lhs - rhs }
        if op == 20 { return lhs * rhs }
        if op == 21 { return lhs / rhs }

        if op == 22 {
            let out = 0
            if lhs < rhs { let out = 1 }
            return out
        }
        if op == 23 {
            let out = 0
            if lhs <= rhs { let out = 1 }
            return out
        }
        if op == 26 {
            let out = 0
            if lhs > rhs { let out = 1 }
            return out
        }
        if op == 27 {
            let out = 0
            if lhs >= rhs { let out = 1 }
            return out
        }
        if op == 16 {
            let out = 0
            if lhs == rhs { let out = 1 }
            return out
        }
        if op == 17 {
            let out = 0
            if lhs != rhs { let out = 1 }
            return out
        }
        if op == 24 {
            let out = 0
            if lhs != 0 and rhs != 0 { let out = 1 }
            return out
        }
        if op == 25 {
            let out = 0
            if lhs != 0 or rhs != 0 { let out = 1 }
            return out
        }

        return 0
    }

    if tag == 304 { return ceval_call(expr, envs) }
    return 0
}

fn ceval_render_string(raw, envs) {
    let vals_env = ceval_env_vals(envs)
    let defs_env = ceval_env_defs(envs)

    let i = 0
    let n = str_len(raw)
    while i < n {
        let c = str_char(raw, i)

        if c == 123 {
            let j = i + 1
            while j < n and str_char(raw, j) != 125 { let j = j + 1 }

            if j < n {
                let expr = str_slice(raw, i + 1, j)
                let k = 0
                let elen = str_len(expr)

                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }
                let start_name = k
                while k < elen and is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                let name = str_slice(expr, start_name, k)
                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }

                let did_call = 0

                // func call: {name(16)} or {name(x)}
                if k < elen and str_char(expr, k) == 40 {
                    let did_call = 1
                    let k = k + 1
                    while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }

                    let arg_val = 0
                    let parsed_num = 0

                    if k < elen and is_digit_char(str_char(expr, k)) != 0 {
                        let start = k
                        while k < elen and is_digit_char(str_char(expr, k)) != 0 { let k = k + 1 }
                        let arg_val = parse_int(str_slice(expr, start, k))
                        let parsed_num = 1
                    }

                    if parsed_num == 0 {
                        let start = k
                        while k < elen and is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                        let arg_name = str_slice(expr, start, k)
                        let arg_val = env_find(vals_env, arg_name)
                    }

                    let args = list_create()
                    list_push(args, arg_val)
                    let v = ceval_call_value(name, args, envs)
                    print(v)
                }

                // variable: {x}
                if did_call == 0 {
                    let def = env_find(defs_env, name)
                    if def != 0 {
                        let v = env_find(vals_env, name)
                        print(v)
                    }
                    if def == 0 {
                        print_char(123)
                        print_bytes(name)
                        print_char(125)
                    }
                }

                let i = j + 1
            }

            if j >= n {
                print_char(123)
                let i = i + 1
            }
        }

        if c != 123 {
            let handled = 0
            if c == 92 and (i + 1) < n and str_char(raw, i + 1) == 110 {
                print_char(10)
                let i = i + 2
                let handled = 1
            }
            if handled == 0 {
                print_char(c)
                let i = i + 1
            }
        }
    }
    return 0
}

fn ceval_stmt(stmt, envs) {
    let tag = list_get(stmt, 0)

    if tag == 102 { return ceval_block(stmt, envs) }

    if tag == 200 {
        let name = list_get(stmt, 1)
        let v = ceval_expr(list_get(stmt, 2), envs)
        if str_len(name) != 0 {
            env_set(ceval_env_vals(envs), name, v)
            env_set(ceval_env_defs(envs), name, 1)
        }
        return ceval_ret_pair(0, 0)
    }

    if tag == 206 {
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        let rhs = ceval_expr(list_get(stmt, 3), envs)
        let out = rhs
        if op == 30 { let out = env_find(ceval_env_vals(envs), name) + out }
        if str_len(name) != 0 {
            env_set(ceval_env_vals(envs), name, out)
            env_set(ceval_env_defs(envs), name, 1)
        }
        return ceval_ret_pair(0, 0)
    }

    if tag == 208 {
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        let idx = ceval_expr(list_get(stmt, 3), envs)
        let rhs = ceval_expr(list_get(stmt, 4), envs)
        let list_handle = env_find(ceval_env_vals(envs), name)
        let out = rhs
        if op == 30 { let out = list_get(list_handle, idx) + out }
        list_set(list_handle, idx, out)
        return ceval_ret_pair(0, 0)
    }

    if tag == 201 {
        let expr = list_get(stmt, 1)
        if list_get(expr, 0) == 301 { ceval_render_string(list_get(expr, 1), envs) }
        if list_get(expr, 0) != 301 { print(ceval_expr(expr, envs)) }
        return ceval_ret_pair(0, 0)
    }

    if tag == 202 {
        let expr = list_get(stmt, 1)
        if expr == 0 { return ceval_ret_pair(1, 0) }
        return ceval_ret_pair(1, ceval_expr(expr, envs))
    }

    if tag == 209 { return ceval_ret_pair(2, 0) }
    if tag == 210 { return ceval_ret_pair(3, 0) }

    if tag == 203 {
        if ceval_expr(list_get(stmt, 1), envs) != 0 {
            return ceval_block(list_get(stmt, 2), envs)
        }
        let else_block = list_get(stmt, 3)
        if else_block != 0 {
            return ceval_block(else_block, envs)
        }
        return ceval_ret_pair(0, 0)
    }

    if tag == 204 {
        let cond_expr = list_get(stmt, 1)
        let body = list_get(stmt, 2)
        while ceval_expr(cond_expr, envs) != 0 {
            let r = ceval_block(body, envs)
            let k = ceval_ret_kind(r)
            if k == 1 { return r }
            if k == 2 { return ceval_ret_pair(0, 0) }
        }
        return ceval_ret_pair(0, 0)
    }

    if tag == 207 {
        let name = list_get(stmt, 1)
        let start = ceval_expr(list_get(stmt, 2), envs)
        let end = ceval_expr(list_get(stmt, 3), envs)
        let body = list_get(stmt, 4)
        while start < end {
            if str_len(name) != 0 {
                env_set(ceval_env_vals(envs), name, start)
                env_set(ceval_env_defs(envs), name, 1)
            }
            let r = ceval_block(body, envs)
            let k = ceval_ret_kind(r)
            if k == 1 { return r }
            if k == 2 { return ceval_ret_pair(0, 0) }
            let start = start + 1
        }
        return ceval_ret_pair(0, 0)
    }

    if tag == 205 {
        ceval_expr(list_get(stmt, 1), envs)
        return ceval_ret_pair(0, 0)
    }

    return ceval_ret_pair(0, 0)
}

fn ceval_block(block, envs) {
    let stmts = list_get(block, 1)
    let i = 0
    let n = list_len(stmts)
    while i < n {
        let r = ceval_stmt(list_get(stmts, i), envs)
        if ceval_ret_kind(r) != 0 { return r }
        let i = i + 1
    }
    return ceval_ret_pair(0, 0)
}

fn ceval_program(prog, prog_args) {
    let funcs = list_get(prog, 1)

    let ceval_funcs = env_create(0)
    let i = 0
    let n = list_len(funcs)
    while i < n {
        let f = list_get(funcs, i)
        env_set(ceval_funcs, list_get(f, 1), f)
        let i = i + 1
    }

    let ceval_args = prog_args

    let vals = env_create(0)
    let defs = env_create(0)
    let envs = pair(vals, defs)
    let args = list_create()
    ceval_call_value("main", args, envs)
    return 0
}

// --- Bytecode compiler + VM (first real codegen path) ---
// Instruction format: list [op, a?, b?]
// Ops:
//   1  PUSH_INT value
//   2  PUSH_STR value
//   3  LOAD name
//   4  STORE name              (sets vals + defs)
//   10 BIN op_kind             (token kind: + - * / < <= > >= == != and or)
//   11 CALL name argc
//   12 POP
//   13 JMP target_ip
//   14 JMP_Z target_ip         (pops cond; jumps if cond == 0)
//   15 RET                     (pops value)
//   16 PRINT                   (pops value)
//   17 PRINT_STR raw           (renders interpolation + \\n escapes)
//   18 DUP2                    (duplicates top 2 stack values)
//   19 TMP_SET idx             (pops value into temp slot)
//   20 TMP_GET idx             (pushes temp slot)
//   99 TRAP message            (prints message + returns 0)

fn bc_stack_create() {
    let st = list_create()
    list_push(st, list_create()) // values
    list_push(st, 0) // sp
    return st
}

fn bc_stack_vals(st) { return list_get(st, 0) }
fn bc_stack_sp(st) { return list_get(st, 1) }

fn bc_stack_push(st, v) {
    let vals = bc_stack_vals(st)
    let sp = bc_stack_sp(st)
    let n = list_len(vals)
    if sp < n {
        list_set(vals, sp, v)
    }
    if sp == n {
        list_push(vals, v)
    }
    list_set(st, 1, sp + 1)
    return 0
}

fn bc_stack_pop(st) {
    let vals = bc_stack_vals(st)
    let sp = bc_stack_sp(st)
    if sp <= 0 { return 0 }
    let sp = sp - 1
    list_set(st, 1, sp)
    return list_get(vals, sp)
}

fn bc_ins0(op) {
    let ins = list_create()
    list_push(ins, op)
    return ins
}
fn bc_ins1(op, a) {
    let ins = list_create()
    list_push(ins, op)
    list_push(ins, a)
    return ins
}
fn bc_ins2(op, a, b) {
    let ins = list_create()
    list_push(ins, op)
    list_push(ins, a)
    list_push(ins, b)
    return ins
}

fn bc_emit(code, ins) {
    list_push(code, ins)
    return list_len(code) - 1
}

fn bc_patch_target(code, ins_idx, target) {
    let ins = list_get(code, ins_idx)
    list_set(ins, 1, target)
    return 0
}

fn bc_patch_jmps(code, jmps, target) {
    let i = 0
    let n = list_len(jmps)
    while i < n {
        bc_patch_target(code, list_get(jmps, i), target)
        let i = i + 1
    }
    return 0
}

fn bc_loop_ctx_create() {
    let ctx = list_create()
    list_push(ctx, list_create()) // breaks
    list_push(ctx, list_create()) // continues
    return ctx
}

fn bc_loop_breaks(ctx) { return list_get(ctx, 0) }
fn bc_loop_conts(ctx) { return list_get(ctx, 1) }

fn bc_ctx_create() {
    let ctx = list_create()
    list_push(ctx, 0) // next_tmp
    return ctx
}

fn bc_alloc_tmp(ctx) {
    let next = list_get(ctx, 0)
    list_set(ctx, 0, next + 1)
    return next
}

fn bc_compile_expr(expr, code, ctx) {
    let tag = list_get(expr, 0)

    if tag == 300 {
        bc_emit(code, bc_ins1(1, list_get(expr, 1)))
        return 0
    }
    if tag == 301 {
        bc_emit(code, bc_ins1(2, list_get(expr, 1)))
        return 0
    }
    if tag == 302 {
        bc_emit(code, bc_ins1(3, list_get(expr, 1)))
        return 0
    }

    if tag == 303 {
        bc_compile_expr(list_get(expr, 2), code, ctx)
        bc_compile_expr(list_get(expr, 3), code, ctx)
        bc_emit(code, bc_ins1(10, list_get(expr, 1)))
        return 0
    }

    if tag == 304 {
        let name = list_get(expr, 1)
        let args = list_get(expr, 2)
        let i = 0
        let n = list_len(args)
        while i < n {
            bc_compile_expr(list_get(args, i), code, ctx)
            let i = i + 1
        }
        bc_emit(code, bc_ins2(11, name, n))
        return 0
    }

    return 0
}

fn bc_compile_block(block, code, ctx, loop_ctx) {
    let stmts = list_get(block, 1)
    let i = 0
    let n = list_len(stmts)
    while i < n {
        bc_compile_stmt(list_get(stmts, i), code, ctx, loop_ctx)
        let i = i + 1
    }
    return 0
}

fn bc_compile_stmt(stmt, code, ctx, loop_ctx) {
    let tag = list_get(stmt, 0)

    if tag == 102 { return bc_compile_block(stmt, code, ctx, loop_ctx) }

    if tag == 200 {
        let name = list_get(stmt, 1)
        let expr = list_get(stmt, 2)
        bc_compile_expr(expr, code, ctx)
        if str_len(name) != 0 { bc_emit(code, bc_ins1(4, name)) }
        if str_len(name) == 0 { bc_emit(code, bc_ins0(12)) }
        return 0
    }

    if tag == 206 {
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        let expr = list_get(stmt, 3)

        if op == 30 { bc_emit(code, bc_ins1(3, name)) }
        bc_compile_expr(expr, code, ctx)
        if op == 30 { bc_emit(code, bc_ins1(10, 18)) } // plus

        if str_len(name) != 0 { bc_emit(code, bc_ins1(4, name)) }
        if str_len(name) == 0 { bc_emit(code, bc_ins0(12)) }
        return 0
    }

    if tag == 208 {
        let op = list_get(stmt, 1)
        let name = list_get(stmt, 2)
        let idx_expr = list_get(stmt, 3)
        let val_expr = list_get(stmt, 4)

        bc_emit(code, bc_ins1(3, name)) // list_handle
        bc_compile_expr(idx_expr, code, ctx)

        if op == 30 {
            bc_emit(code, bc_ins0(18)) // DUP2
            bc_emit(code, bc_ins2(11, "list_get", 2))
        }

        bc_compile_expr(val_expr, code, ctx)
        if op == 30 { bc_emit(code, bc_ins1(10, 18)) } // plus

        bc_emit(code, bc_ins2(11, "list_set", 3))
        bc_emit(code, bc_ins0(12)) // POP return
        return 0
    }

    if tag == 201 {
        let expr = list_get(stmt, 1)
        if list_get(expr, 0) == 301 {
            bc_emit(code, bc_ins1(17, list_get(expr, 1)))
        }
        if list_get(expr, 0) != 301 {
            bc_compile_expr(expr, code, ctx)
            bc_emit(code, bc_ins0(16))
        }
        return 0
    }

    if tag == 202 {
        let expr = list_get(stmt, 1)
        if expr == 0 { bc_emit(code, bc_ins1(1, 0)) }
        if expr != 0 { bc_compile_expr(expr, code, ctx) }
        bc_emit(code, bc_ins0(15))
        return 0
    }

    if tag == 209 {
        if loop_ctx == 0 {
            bc_emit(code, bc_ins1(99, "break outside loop\n"))
            return 0
        }
        let j = bc_emit(code, bc_ins1(13, 0))
        list_push(bc_loop_breaks(loop_ctx), j)
        return 0
    }

    if tag == 210 {
        if loop_ctx == 0 {
            bc_emit(code, bc_ins1(99, "continue outside loop\n"))
            return 0
        }
        let j = bc_emit(code, bc_ins1(13, 0))
        list_push(bc_loop_conts(loop_ctx), j)
        return 0
    }

    if tag == 203 {
        bc_compile_expr(list_get(stmt, 1), code, ctx)
        let j_false = bc_emit(code, bc_ins1(14, 0))
        bc_compile_block(list_get(stmt, 2), code, ctx, loop_ctx)

        let else_block = list_get(stmt, 3)
        if else_block != 0 {
            let j_end = bc_emit(code, bc_ins1(13, 0))
            let else_ip = list_len(code)
            bc_patch_target(code, j_false, else_ip)
            bc_compile_block(else_block, code, ctx, loop_ctx)
            let end_ip = list_len(code)
            bc_patch_target(code, j_end, end_ip)
        }
        if else_block == 0 {
            bc_patch_target(code, j_false, list_len(code))
        }
        return 0
    }

    if tag == 204 {
        let loop_ip = list_len(code)
        bc_compile_expr(list_get(stmt, 1), code, ctx)
        let j_end = bc_emit(code, bc_ins1(14, 0))

        let inner = bc_loop_ctx_create()
        bc_compile_block(list_get(stmt, 2), code, ctx, inner)

        bc_emit(code, bc_ins1(13, loop_ip))

        let end_ip = list_len(code)
        bc_patch_target(code, j_end, end_ip)
        bc_patch_jmps(code, bc_loop_breaks(inner), end_ip)
        bc_patch_jmps(code, bc_loop_conts(inner), loop_ip)
        return 0
    }

    if tag == 207 {
        let name = list_get(stmt, 1)
        let start_tmp = bc_alloc_tmp(ctx)
        let end_tmp = bc_alloc_tmp(ctx)

        bc_compile_expr(list_get(stmt, 2), code, ctx)
        bc_emit(code, bc_ins1(19, start_tmp))
        bc_compile_expr(list_get(stmt, 3), code, ctx)
        bc_emit(code, bc_ins1(19, end_tmp))

        let loop_ip = list_len(code)
        bc_emit(code, bc_ins1(20, start_tmp))
        bc_emit(code, bc_ins1(20, end_tmp))
        bc_emit(code, bc_ins1(10, 22)) // <
        let j_end = bc_emit(code, bc_ins1(14, 0))

        if str_len(name) != 0 {
            bc_emit(code, bc_ins1(20, start_tmp))
            bc_emit(code, bc_ins1(4, name))
        }

        let inner = bc_loop_ctx_create()
        bc_compile_block(list_get(stmt, 4), code, ctx, inner)

        let cont_ip = list_len(code)
        bc_patch_jmps(code, bc_loop_conts(inner), cont_ip)

        bc_emit(code, bc_ins1(20, start_tmp))
        bc_emit(code, bc_ins1(1, 1))
        bc_emit(code, bc_ins1(10, 18)) // +
        bc_emit(code, bc_ins1(19, start_tmp))
        bc_emit(code, bc_ins1(13, loop_ip))

        let end_ip = list_len(code)
        bc_patch_target(code, j_end, end_ip)
        bc_patch_jmps(code, bc_loop_breaks(inner), end_ip)
        return 0
    }

    if tag == 205 {
        bc_compile_expr(list_get(stmt, 1), code, ctx)
        bc_emit(code, bc_ins0(12))
        return 0
    }

    return 0
}

fn bc_compile_func(func_node) {
    let name = list_get(func_node, 1)
    let params = list_get(func_node, 7)
    let body = list_get(func_node, 6)

    let ctx = bc_ctx_create()
    let code = list_create()
    bc_compile_block(body, code, ctx, 0)

    let out = list_create()
    list_push(out, name)
    list_push(out, params)
    list_push(out, code)
    return out
}

fn bc_compile_program(prog) {
    let funcs = list_get(prog, 1)
    let bc_funcs = env_create(0)

    let i = 0
    let n = list_len(funcs)
    while i < n {
        let f = list_get(funcs, i)
        let bc_f = bc_compile_func(f)
        env_set(bc_funcs, list_get(f, 1), bc_f)
        let i = i + 1
    }
    return bc_funcs
}

fn bc_call_value(name, args, envs, bc_funcs, prog_args) {
    // Builtins
    if str_eq(name, "env_create") { return env_create(list_get(args, 0)) }
    if str_eq(name, "env_set") {
        env_set(list_get(args, 0), list_get(args, 1), list_get(args, 2))
        return 0
    }
    if str_eq(name, "env_find") { return env_find(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "env_destroy") {
        env_destroy(list_get(args, 0))
        return 0
    }

    if str_eq(name, "str_len") { return str_len(list_get(args, 0)) }
    if str_eq(name, "str_char") { return str_char(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "str_slice") { return str_slice(list_get(args, 0), list_get(args, 1), list_get(args, 2)) }

    if str_eq(name, "print_bytes") {
        print_bytes(list_get(args, 0))
        return 0
    }
    if str_eq(name, "print_char") {
        print_char(list_get(args, 0))
        return 0
    }

    if str_eq(name, "list_create") { return list_create() }
    if str_eq(name, "list_push") {
        list_push(list_get(args, 0), list_get(args, 1))
        return 0
    }
    if str_eq(name, "list_len") { return list_len(list_get(args, 0)) }
    if str_eq(name, "list_get") { return list_get(list_get(args, 0), list_get(args, 1)) }
    if str_eq(name, "list_set") {
        list_set(list_get(args, 0), list_get(args, 1), list_get(args, 2))
        return 0
    }
    if str_eq(name, "list_destroy") {
        list_destroy(list_get(args, 0))
        return 0
    }

    if str_eq(name, "read_file") { return read_file(list_get(args, 0)) }
    if str_eq(name, "write_file") {
        write_file(list_get(args, 0), list_get(args, 1))
        return 0
    }

    if str_eq(name, "arg_len") { return list_len(prog_args) }
    if str_eq(name, "arg_get") {
        let idx = list_get(args, 0)
        let n = list_len(prog_args)
        if idx < 0 { return "" }
        if idx < n { return list_get(prog_args, idx) }
        return ""
    }

    // User-defined
    let f = env_find(bc_funcs, name)
    if f == 0 {
        print("[undefined function] {name}\n")
        return 0
    }
    return bc_exec_func(f, args, envs, bc_funcs, prog_args)
}

fn bc_render_string(raw, envs, bc_funcs, prog_args) {
    let vals_env = ceval_env_vals(envs)
    let defs_env = ceval_env_defs(envs)

    let i = 0
    let n = str_len(raw)
    while i < n {
        let c = str_char(raw, i)

        if c == 123 {
            let j = i + 1
            while j < n and str_char(raw, j) != 125 { let j = j + 1 }

            if j < n {
                let expr = str_slice(raw, i + 1, j)
                let k = 0
                let elen = str_len(expr)

                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }
                let start_name = k
                while k < elen and is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                let name = str_slice(expr, start_name, k)
                while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }

                let did_call = 0

                // func call: {name(16)} or {name(x)}
                if k < elen and str_char(expr, k) == 40 {
                    let did_call = 1
                    let k = k + 1
                    while k < elen and (str_char(expr, k) == 32 or str_char(expr, k) == 9) { let k = k + 1 }

                    let arg_val = 0
                    let parsed_num = 0

                    if k < elen and is_digit_char(str_char(expr, k)) != 0 {
                        let start = k
                        while k < elen and is_digit_char(str_char(expr, k)) != 0 { let k = k + 1 }
                        let arg_val = parse_int(str_slice(expr, start, k))
                        let parsed_num = 1
                    }

                    if parsed_num == 0 {
                        let start = k
                        while k < elen and is_ident_char(str_char(expr, k)) != 0 { let k = k + 1 }
                        let arg_name = str_slice(expr, start, k)
                        let arg_val = env_find(vals_env, arg_name)
                    }

                    let args = list_create()
                    list_push(args, arg_val)
                    let v = bc_call_value(name, args, envs, bc_funcs, prog_args)
                    print(v)
                }

                // variable: {x}
                if did_call == 0 {
                    let def = env_find(defs_env, name)
                    if def != 0 {
                        let v = env_find(vals_env, name)
                        print(v)
                    }
                    if def == 0 {
                        print_char(123)
                        print_bytes(name)
                        print_char(125)
                    }
                }

                let i = j + 1
            }

            if j >= n {
                print_char(123)
                let i = i + 1
            }
        }

        if c != 123 {
            let handled = 0
            if c == 92 and (i + 1) < n and str_char(raw, i + 1) == 110 {
                print_char(10)
                let i = i + 2
                let handled = 1
            }
            if handled == 0 {
                print_char(c)
                let i = i + 1
            }
        }
    }
    return 0
}

fn bc_exec_func(func_rec, args, caller_envs, bc_funcs, prog_args) {
    let parent_vals = ceval_env_vals(caller_envs)
    let parent_defs = ceval_env_defs(caller_envs)

    let vals = env_create(parent_vals)
    let defs = env_create(parent_defs)
    let envs = pair(vals, defs)

    let params = list_get(func_rec, 1)
    let argc = list_len(args)
    let i = 0
    let n = list_len(params)
    while i < n {
        let p = list_get(params, i)
        if str_len(p) != 0 {
            let v = 0
            if i < argc { let v = list_get(args, i) }
            env_set(vals, p, v)
            env_set(defs, p, 1)
        }
        let i = i + 1
    }

    let code = list_get(func_rec, 2)
    let ip = 0
    let ncode = list_len(code)

    let st = bc_stack_create()
    let tmps = list_create()

    while ip < ncode {
        let ins = list_get(code, ip)
        let op = list_get(ins, 0)

        if op == 1 { bc_stack_push(st, list_get(ins, 1)); let ip = ip + 1 }
        if op == 2 { bc_stack_push(st, list_get(ins, 1)); let ip = ip + 1 }

        if op == 3 {
            bc_stack_push(st, env_find(vals, list_get(ins, 1)))
            let ip = ip + 1
        }

        if op == 4 {
            let name = list_get(ins, 1)
            let v = bc_stack_pop(st)
            if str_len(name) != 0 {
                env_set(vals, name, v)
                env_set(defs, name, 1)
            }
            let ip = ip + 1
        }

        if op == 10 {
            let k = list_get(ins, 1)
            let rhs = bc_stack_pop(st)
            let lhs = bc_stack_pop(st)
            let out = 0

            if k == 18 { let out = lhs + rhs }
            if k == 19 { let out = lhs - rhs }
            if k == 20 { let out = lhs * rhs }
            if k == 21 { let out = lhs / rhs }

            if k == 22 { if lhs < rhs { let out = 1 } }
            if k == 23 { if lhs <= rhs { let out = 1 } }
            if k == 26 { if lhs > rhs { let out = 1 } }
            if k == 27 { if lhs >= rhs { let out = 1 } }
            if k == 16 { if lhs == rhs { let out = 1 } }
            if k == 17 { if lhs != rhs { let out = 1 } }
            if k == 24 { if lhs != 0 and rhs != 0 { let out = 1 } }
            if k == 25 { if lhs != 0 or rhs != 0 { let out = 1 } }

            bc_stack_push(st, out)
            let ip = ip + 1
        }

        if op == 11 {
            let name = list_get(ins, 1)
            let narg = list_get(ins, 2)
            let tmp = list_create()
            let i = 0
            while i < narg {
                list_push(tmp, bc_stack_pop(st))
                let i = i + 1
            }

            let call_args = list_create()
            let i = narg - 1
            while 0 <= i {
                list_push(call_args, list_get(tmp, i))
                let i = i - 1
            }

            bc_stack_push(st, bc_call_value(name, call_args, envs, bc_funcs, prog_args))
            let ip = ip + 1
        }

        if op == 12 { _ = bc_stack_pop(st); let ip = ip + 1 }

        if op == 13 { let ip = list_get(ins, 1) }

        if op == 14 {
            let cond = bc_stack_pop(st)
            if cond == 0 { let ip = list_get(ins, 1) }
            if cond != 0 { let ip = ip + 1 }
        }

        if op == 15 { return bc_stack_pop(st) }

        if op == 16 {
            print(bc_stack_pop(st))
            let ip = ip + 1
        }

        if op == 17 {
            bc_render_string(list_get(ins, 1), envs, bc_funcs, prog_args)
            let ip = ip + 1
        }

        if op == 18 {
            let sp = bc_stack_sp(st)
            if sp < 2 {
                print_bytes("dup2 underflow\n")
                return 0
            }
            let stack_vals = bc_stack_vals(st)
            let a = list_get(stack_vals, sp - 2)
            let b = list_get(stack_vals, sp - 1)
            bc_stack_push(st, a)
            bc_stack_push(st, b)
            let ip = ip + 1
        }

        if op == 19 {
            list_set(tmps, list_get(ins, 1), bc_stack_pop(st))
            let ip = ip + 1
        }

        if op == 20 {
            bc_stack_push(st, list_get(tmps, list_get(ins, 1)))
            let ip = ip + 1
        }

        if op == 99 {
            print_bytes(list_get(ins, 1))
            return 0
        }
    }

    return 0
}

fn bc_run_program(bc_funcs, prog_args) {
    let main = env_find(bc_funcs, "main")
    if main == 0 {
        print("[no main]\n")
        return 0
    }

    let vals = env_create(0)
    let defs = env_create(0)
    let envs = pair(vals, defs)
    let args = list_create()
    _ = bc_exec_func(main, args, envs, bc_funcs, prog_args)
    return 0
}

fn bc_dump_program(prog, bc_funcs) {
    let funcs = list_get(prog, 1)
    let i = 0
    let n = list_len(funcs)
    while i < n {
        let f = list_get(funcs, i)
        let name = list_get(f, 1)
        let rec = env_find(bc_funcs, name)
        print("fn {name}\n")
        let code = list_get(rec, 2)
        let ip = 0
        let ncode = list_len(code)
        while ip < ncode {
            let ins = list_get(code, ip)
            let op = list_get(ins, 0)
            print("  {ip}: op={op}\n")
            let ip = ip + 1
        }
        print("\n")
        let i = i + 1
    }
    return 0
}

fn main() {
    let do_parse = 0
    let do_eval = 0
    let do_bc = 0
    let do_bcvex = 0
    let do_bcdump = 0
    let do_bcsave = 0
    let dump_tree = 0
    let path = "src/vex.vex"
    let out_path = ""
    if 1 < arg_len() {
        let first = arg_get(1)

        if str_eq(first, "parse") {
            let do_parse = 1
            if 2 < arg_len() { let path = arg_get(2) }
            if 3 < arg_len() {
                if str_eq(arg_get(3), "dump") { let dump_tree = 1 }
            }
        }

        if str_eq(first, "eval") {
            let do_eval = 1
            if 2 < arg_len() { let path = arg_get(2) }
        }

        if str_eq(first, "bc") {
            let do_bc = 1
            if 2 < arg_len() { let path = arg_get(2) }
        }

        if str_eq(first, "bcvex") {
            let do_bcvex = 1
            if 2 < arg_len() { let path = arg_get(2) }
        }

        if str_eq(first, "bcdump") {
            let do_bcdump = 1
            if 2 < arg_len() { let path = arg_get(2) }
        }

        if str_eq(first, "bcsave") {
            let do_bcsave = 1
            if 2 < arg_len() { let path = arg_get(2) }
            if 3 < arg_len() { let out_path = arg_get(3) }
        }

        if do_parse == 0 and do_eval == 0 and str_eq(first, "lex") {
            if 2 < arg_len() { let path = arg_get(2) }
        }

        if do_parse == 0 and do_eval == 0 and do_bc == 0 and do_bcvex == 0 and do_bcdump == 0 and do_bcsave == 0 and str_eq(first, "lex") == 0 and str_eq(first, "parse") == 0 and str_eq(first, "eval") == 0 and str_eq(first, "bc") == 0 and str_eq(first, "bcvex") == 0 and str_eq(first, "bcdump") == 0 and str_eq(first, "bcsave") == 0 {
            let path = first
        }
    }

    let src = read_file(path)
    let toks = tokenize_with_pos(src)

    if do_parse == 1 {
        let imports_seen = env_create(0)
        env_set(imports_seen, path, 1)
        let prog = parse_program(toks, path, src, imports_seen)
        if dump_tree == 1 { dump_program_tree(prog) }
        if dump_tree == 0 { dump_program_summary(prog) }
        return
    }

    if do_eval == 1 {
        let imports_seen = env_create(0)
        env_set(imports_seen, path, 1)
        let prog = parse_program(toks, path, src, imports_seen)
        let prog_args = list_create()
        list_push(prog_args, path)
        let i = 3
        while i < arg_len() {
            list_push(prog_args, arg_get(i))
            let i = i + 1
        }
        ceval_program(prog, prog_args)
        return
    }

    if do_bc == 1 {
        let imports_seen = env_create(0)
        env_set(imports_seen, path, 1)
        let prog = parse_program(toks, path, src, imports_seen)
        let prog_args = list_create()
        list_push(prog_args, path)
        let i = 3
        while i < arg_len() {
            list_push(prog_args, arg_get(i))
            let i = i + 1
        }
        let bc_funcs = bc_compile_program(prog)
        bc_run(bc_funcs, prog_args)
        return
    }

    if do_bcvex == 1 {
        let imports_seen = env_create(0)
        env_set(imports_seen, path, 1)
        let prog = parse_program(toks, path, src, imports_seen)
        let prog_args = list_create()
        list_push(prog_args, path)
        let i = 3
        while i < arg_len() {
            list_push(prog_args, arg_get(i))
            let i = i + 1
        }
        let bc_funcs = bc_compile_program(prog)
        bc_run_program(bc_funcs, prog_args)
        return
    }

    if do_bcdump == 1 {
        let imports_seen = env_create(0)
        env_set(imports_seen, path, 1)
        let prog = parse_program(toks, path, src, imports_seen)
        let bc_funcs = bc_compile_program(prog)
        bc_dump_program(prog, bc_funcs)
        return
    }

    if do_bcsave == 1 {
        if str_len(out_path) == 0 {
            print("error: missing output path\n")
            return
        }
        let imports_seen = env_create(0)
        env_set(imports_seen, path, 1)
        let prog = parse_program(toks, path, src, imports_seen)
        let bc_funcs = bc_compile_program(prog)
        bc_save(bc_funcs, out_path)
        print("wrote {out_path}\n")
        return
    }

    let total = list_len(toks) / 4
    print("tokenized {path}\n")
    print("tokens: {total}\n")
    dump_tokens(toks, 20)
}
